<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>acwing每日一题第四周</title>
      <link href="/2024/03/22/acwing%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC%E5%9B%9B%E5%91%A8/"/>
      <url>/2024/03/22/acwing%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%AC%AC%E5%9B%9B%E5%91%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="ACWING每日一题第四周习题"><a href="#ACWING每日一题第四周习题" class="headerlink" title="ACWING每日一题第四周习题"></a>ACWING每日一题第四周习题</h2><h3 id="日期差值"><a href="#日期差值" class="headerlink" title="日期差值"></a>日期差值</h3><p>有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含多组测试数据。</p><p>每组数据占两行，分别表示两个日期，形式为 <code>YYYYMMDD</code>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>每组数据输出一行，即日期差值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>年份范围 [1,9999][1,9999],<br>保证输入日期合法。<br>测试数据的组数不超过 100100。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20110412</span><br><span class="line">20110422</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><p>首先根据日期模板先把每年的月份写出来</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int months[]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再写一个函数判断是否为闰年，是闰年则2月+1天</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int is_leap(int year)</span><br><span class="line">&#123;</span><br><span class="line">if((year%100&amp;&amp;year%4==0)||year%400==0)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个函数来获取每月有多少天</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int get_month(int year,int month)</span><br><span class="line">&#123;</span><br><span class="line">res=months[month];</span><br><span class="line">if(month=2) res+=is_leap(int year);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后写出计算总日期的函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int get_totles(int year,int month,int day)</span><br><span class="line">&#123;</span><br><span class="line">int res=0;</span><br><span class="line">for(int i=1;i&lt;year;i++)</span><br><span class="line">&#123;</span><br><span class="line">res=res+365+is_leap(i);</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;month;i++)</span><br><span class="line">&#123;</span><br><span class="line">res=res+get_month(year,i);</span><br><span class="line">&#125;</span><br><span class="line">return res+day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后写出主函数，因为会有多组数据同时测试，所以需要写出循环,并且数据中没有给出哪组减去哪组，需要加上绝对值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int y1,m1,d1,y2,m2,d2;</span><br><span class="line">while(scanf(&quot;%04d%02d%02d&quot;,&amp;y1,&amp;m1,&amp;d1))</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%04d%02d%02d&quot;,&amp;y2,m2,d2);</span><br><span class="line">printf(&quot;%d&quot;,abs(get_totles(y1,m1,d1)-get_totles(y2,m2,d2)+1));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终代码如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int months[]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;</span><br><span class="line"></span><br><span class="line">int is_leap(int year)</span><br><span class="line">&#123;</span><br><span class="line">if((year%100&amp;&amp;year%4==0)||year%400==0)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int get_month(int year,int month)</span><br><span class="line">&#123;</span><br><span class="line">int res = months[month];</span><br><span class="line">if(month==2) res+=is_leap(year);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">int get_totles(int year,int month, int day)</span><br><span class="line">&#123;</span><br><span class="line">int res = 0;</span><br><span class="line">for(int i=1;i&lt;year;i++)&#123;</span><br><span class="line">res=res+365+is_leap(i);</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;month;i++)</span><br><span class="line">&#123;</span><br><span class="line">res=res+get_month(year,i);</span><br><span class="line">&#125;</span><br><span class="line">return res+day;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int y1,m1,d1,y2,m2,d2;</span><br><span class="line">while(scanf(&quot;%04d%02d%02d&quot;,&amp;y1,&amp;m1,&amp;d1)!=-1)&#123;</span><br><span class="line">scanf(&quot;%04d%02d%02d&quot;,&amp;y2,&amp;m2,&amp;d2);</span><br><span class="line">printf(&quot;%d\n&quot;,abs(get_totles(y1,m1,d1)-get_totles(y2,m2,d2))+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2024/03/20/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2024/03/20/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯23年原题</title>
      <link href="/2024/03/20/%E8%93%9D%E6%A1%A5%E6%9D%AF23%E5%B9%B4%E5%8E%9F%E9%A2%98/"/>
      <url>/2024/03/20/%E8%93%9D%E6%A1%A5%E6%9D%AF23%E5%B9%B4%E5%8E%9F%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯模拟赛</title>
      <link href="/2024/03/12/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9F%E8%B5%9B/"/>
      <url>/2024/03/12/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h5 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a><strong>第一题</strong></h5><p><strong>【问题描述】</strong></p><p>　　请问 2023 有多少个<a href="https://so.csdn.net/so/search?q=%E7%BA%A6%E6%95%B0&spm=1001.2101.3001.7020">约数</a>？即有多少个正整数，使得 2023 是这个正整数的整数倍。</p><p><strong>【问题描述】</strong></p><p>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p><p>求有多少约数，需要把1和本身也算上</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int n=2023,num=0;</span><br><span class="line">for(int i=1;i&lt;=2023;i++)&#123;</span><br><span class="line">if(n%i==0)&#123;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; num ;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a><strong>第二题</strong></h5><p><strong>问题描述：</strong></p><p>　请问有多少组整数对 l, r 满足：<br>  　　1. l 和 r 都介于 0 （含）到 100 （含）之间；<br>　　2. r-l &gt;&#x3D; 10。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int num=0;</span><br><span class="line">for(int l=0;l&lt;=100;l++)</span><br><span class="line">&#123;</span><br><span class="line">for(int r=l+10;r&lt;=100;r++)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; num ;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h5><p>【问题描述】</p><p>　　只能被 1 和本身整除的数称为质数。<br>　　请问在 1 （含）到 1000000 （含）中，有多少个质数的各个数位上的数字之和为 23 。<br>　　提示：599 就是这样一个质数，各个数位上的数字之和为 5+9+9&#x3D;23 。</p><p>暴力枚举法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">bool is_prime(int n) &#123;</span><br><span class="line">    if (n &lt;= 1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 2; i * i &lt;= n; ++i) &#123;</span><br><span class="line">        if (n % i == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int digit_sum(int n) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    while (n &gt; 0) &#123;</span><br><span class="line">        sum += n % 10;</span><br><span class="line">        n /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    for (int num = 1; num &lt;= 1000000; ++num) &#123;</span><br><span class="line">        if (is_prime(num) &amp;&amp; digit_sum(num) == 23) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>埃拉托斯特尼筛法：</p><p><img src="https://pic1.zhimg.com/v2-216bb312f6f8c9b272b329cc008c37ec_b.webp" alt="动图"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e6+5,M=1e6;</span><br><span class="line">int prime[N],cnt;</span><br><span class="line">bool st[N];</span><br><span class="line">void Isprime()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=2;i&lt;=M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!st[i]) prime[++cnt]=i;</span><br><span class="line">        for(int j=1;prime[j]*i&lt;=M;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[prime[j]*i]=true;</span><br><span class="line">            if(i%prime[j]==0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Isprime();</span><br><span class="line">    int sum=0;</span><br><span class="line">    for(int i=1;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int x=0,m=prime[i];</span><br><span class="line">        while(m)</span><br><span class="line">        &#123;</span><br><span class="line">            x+=m%10;</span><br><span class="line">            m/=10;</span><br><span class="line">        &#125;</span><br><span class="line">        if(x==23) sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a><strong>第四题</strong></h5><p><strong>【问题描述】</strong></p><p>　　求 12345678901234567890123456789012345678901234567890 除以 2023 的余数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void sub(vector&lt;int&gt; A,int b,int&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=A.size()-1;i&gt;=0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        r=r*10+A[i];</span><br><span class="line">        r%=b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s=&quot;12345678901234567890123456789012345678901234567890&quot;;</span><br><span class="line">    vector&lt;int&gt; A;</span><br><span class="line">    int b=2023;</span><br><span class="line">    for(int i=s.size()-1;i&gt;=0;i--) A.push_back(s[i]-&#x27;0&#x27;);</span><br><span class="line">    int r=0;</span><br><span class="line">    sub(A,b,r);</span><br><span class="line">    cout&lt;&lt;r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h5><p>【问题描述】</p><p>　　对于一个 n 行 m 列的矩阵，它的一个 k 行 k 列的子矩阵是指由矩阵中的连续 k 行、连续 k 列组成的矩阵。<br>　　子矩阵的和是指子矩阵中所有元素的和。现在，小蓝对于一个矩阵中的子矩阵中最大的子矩阵的和很感兴趣。<br>　　例如，对于如下 3 行 4 列的矩阵，2 行 2 列的子矩阵的和的最大值是 8，对应的子矩阵为由最后两行最后两列组成的子矩阵。<br>　　2 0 2 3<br>　　1 1 0 1<br>　　1 2 3 4<br>　　现在，小蓝有一个 30 行 20 列的大矩阵，如下所示，请问它的 5 行 5 列的子矩阵的和的最大值是多少?</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9719 7515 5916 6467 7157 9614 8560 9075 2099 2838 1403 7652 6238 1699 8907 1804 5384 7942 7546 1978</span><br><span class="line">8785 1944 8108 6040 2010 6646 2750 5410 4516 8757 5624 9257 9030 9290 6833 4646 9749 5304 5633 1573</span><br><span class="line">8525 8244 8514 7474 7896 9731 8402 9036 1869 2688 2085 1667 7753 8466 4911 3812 8585 8319 4020 7350</span><br><span class="line">1949 9120 4424 4057 8277 4511 6333 1533 7624 8932 1053 8682 9284 4134 1466 3607 8753 5310 3728 4163</span><br><span class="line">9420 9185 7055 2342 4143 4499 2036 5374 7026 8638 8866 8364 1706 8767 1601 8309 5695 8179 4142 8489</span><br><span class="line">5876 5660 4658 8307 2582 7544 8793 8207 3979 1692 1400 1893 4500 6389 7198 4836 4761 6603 2859 1312</span><br><span class="line">6367 4174 9956 6668 6771 4795 6492 3937 7096 8041 8644 9379 8071 8667 5810 5794 8147 3823 7877 4822</span><br><span class="line">4809 3297 8518 4972 9754 6854 3271 7891 8882 1052 3197 6035 5628 7674 7931 8085 8970 7733 4745 8785</span><br><span class="line">7536 1511 6964 4763 5409 7032 8963 8576 3411 5853 3316 1267 7851 2735 6953 2970 1810 6830 5576 6903</span><br><span class="line">2241 1575 2379 4679 9519 9290 4802 1562 3509 8365 6777 5143 5610 1061 7880 1935 5793 7023 5629 9571</span><br><span class="line">2480 5937 4612 8890 1964 8532 3309 9737 8507 1849 8544 1500 9282 6288 2137 4730 4239 3473 4643 6377</span><br><span class="line">7341 2881 3430 5815 1972 6629 3817 4547 7561 4779 6578 6114 4972 5505 7515 1800 4784 2272 4502 7541</span><br><span class="line">7665 8607 2022 8192 2605 1346 4155 8725 8167 7022 6136 3615 6057 6329 8671 2033 3151 2249 5981 6412</span><br><span class="line">9046 3353 8650 6965 4179 1248 5659 5219 8083 5615 3821 4436 9217 7356 3914 5717 3734 3765 4435 7210</span><br><span class="line">8951 5013 2951 7401 2329 5686 6530 9581 6539 6881 8634 2663 2916 3019 8529 5645 8201 9270 1939 7275</span><br><span class="line">6429 1531 6322 9586 2793 7968 4001 9665 7624 4369 6245 5146 9567 6801 6064 6199 3210 6753 2586 7795</span><br><span class="line">5771 8507 7973 1470 1475 6896 6781 6572 8412 8557 8255 5268 8960 7251 9214 2489 6920 9917 3810 4605</span><br><span class="line">9116 7950 3715 1697 4703 2868 8673 3106 2579 1074 3992 3547 4279 3149 3396 6081 6221 1125 9358 2471</span><br><span class="line">8360 1526 4116 9278 6325 5175 5533 4107 7522 7599 7711 9211 1752 2431 8321 3844 3579 1047 3987 8487</span><br><span class="line">7600 2401 8748 8945 2078 1519 4614 4576 5706 4040 9358 1928 1327 6699 5258 2846 3418 8310 1249 3866</span><br><span class="line">7796 8668 4087 4258 8992 8996 4617 5997 2527 8204 8927 1456 9340 2088 1605 2299 9878 8347 7789 2122</span><br><span class="line">8372 1102 4243 4208 1651 7861 4947 7802 4704 6204 4455 6012 8494 9060 3747 2786 2136 1830 7424 8309</span><br><span class="line">6919 4420 2031 5399 2652 7219 4048 7013 5094 5276 4225 5976 4157 6722 8765 4679 1604 4986 5033 2623</span><br><span class="line">4015 2297 3067 6261 6623 4577 4589 4747 6659 7667 7853 4040 6393 9606 7219 9334 1316 3430 9963 5187</span><br><span class="line">4998 3735 9884 2990 1374 8436 6674 3018 5714 9352 8708 8789 7879 2965 1444 4671 4743 9817 6066 8057</span><br><span class="line">6996 9609 2884 4601 7287 3432 4145 8858 6857 8624 4531 6579 1615 2894 4521 3274 5237 1093 3317 9289</span><br><span class="line">7117 1850 3210 8010 2512 1394 4718 9332 5593 4118 4995 3994 5063 9426 1709 5128 4997 9287 1907 9068</span><br><span class="line">4258 7328 6490 2603 5333 5093 8070 2116 8489 1994 7098 7409 1463 4268 9509 2358 1192 2460 5031 6292</span><br><span class="line">4911 1192 1012 2494 5276 8981 3540 3306 8869 6678 7879 7526 8847 6270 7653 3109 6955 9760 8520 8673</span><br><span class="line">6328 7277 7818 3285 9398 4929 4639 1617 4023 1051 9320 4955 6580 6481 3824 9611 2863 6492 6281 6203</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[55][55],max_;</span><br><span class="line">int check(int h,int l)</span><br><span class="line">&#123;</span><br><span class="line">int sum = 0;</span><br><span class="line"></span><br><span class="line">for(int i=h;i&lt;=h+4;i++)</span><br><span class="line">for(int j=l;j&lt;=l+4;j++)&#123;</span><br><span class="line">sum+=a[i][j];</span><br><span class="line">&#125;return sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;30;i++)</span><br><span class="line">for(int j=0;j&lt;20;j++)</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">for(int i=0;i&lt;30;i++)</span><br><span class="line">for(int j=0;i&lt;20;j++)</span><br><span class="line">if(i+4&lt;30&amp;&amp;j+4&lt;20)</span><br><span class="line">max_=max(max_,check(i,j));</span><br><span class="line">cout&lt;&lt;max_;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h5><p>【问题描述】</p><p>　　小蓝要上一个楼梯，楼梯共有 n 级台阶（即小蓝总共要走 n 级）。小蓝每一步可以走 1 级、2 级或 3 级台阶。<br>　　请问小蓝至少要多少步才能上到楼梯顶端？</p><p>【输入格式】</p><p>　　输入一行包含一个整数 n 。</p><p>【输入格式】</p><p>　　输出一行包含一个整数，表示答案。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;cin&gt;&gt;n;</span><br><span class="line">    int sum;</span><br><span class="line">    if(n%3==0) cout&lt;&lt;n/3;</span><br><span class="line">    else cout&lt;&lt;n/3+1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a><strong>第七题</strong></h5><p><strong>【问题描述】</strong></p><p>　　给定一个仅包含数字字符的字符串，请统计一下这个字符串中出现了多少个值为奇数的数位。</p><p><strong>【输入格式】</strong></p><p>　　输入一行包含一个字符串，仅由数字字符组成。</p><p><strong>【输出格式】</strong></p><p>　　输出一行包含一个整数，表示答案。</p><p>输入样例1：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">123455</span></span><br></pre></td></tr></table></figure><p>输出样例1：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>输入样例2：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">111222333111222333111222333</span></span><br></pre></td></tr></table></figure><p>输出样例2：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">for(int i=0;i&lt;s.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">if((s[i]-&#x27;0&#x27;)&amp;1)</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum;</span><br><span class="line">return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h5><p>【问题描述】</p><p>　　对于一个序列 a[1], a[2], …, a[n]，如果 a[i] 满足 a[i]&lt;a[i-1] 且 a[i]&lt;a[i+1]，则称 a[i] 是一个极小值，如果如果 a[i] 满足 a[i]&gt;a[i-1] 且 a[i]&gt;a[i+1]，则称 a[i] 是一个极大值。<br>　　给定一个序列，请找到极小值中最大的和极大值中最小的。</p><p>【输入格式】</p><p>　　输入的第一行包含一个整数 n ，表示序列的长度。<br>　　第二行包含 n 个整数，相邻的整数之间使用一个空格分隔，表示给定的序列。</p><p>【输出格式】</p><p>　　输出一行包含两个整数，用一个空格分隔，分别表示极小值中最大的和极大值中最小的。输入保证至少存在一个极小值，至少存在一个极大值。</p><p>输入样例：</p><p>8<br>1 8 2 4 4 3 5 3<br>输出样例：</p><p>3 5<br>【评测用例规模与约定】</p><p>　　对于所有评测用例，1 &lt;&#x3D; n &lt;&#x3D; 1000，0 &lt;&#x3D; a[i] &lt;&#x3D; 10000。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5+5;</span><br><span class="line"></span><br><span class="line">int a[N],b[N],c[N],n,k1=0,k2=0;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">if((a[i]&gt;a[i-1])&amp;&amp;a[i]&gt;a[i+1])</span><br><span class="line">b[k1++]=a[i];</span><br><span class="line">if(a[i]&lt;a[i-1]&amp;&amp;a[i]&lt;a[i+1])&#123;</span><br><span class="line">c[k2++]=a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(b,b+k1);</span><br><span class="line">sort(c,c+k2);</span><br><span class="line">cout&lt;&lt;c[k2-1]&lt;&lt;&#x27; &#x27;&lt;&lt; b[0];</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h5><p>【问题描述】</p><p>　　对于一个字符矩阵，其中的一些字符构成字母 Y 是指存在一个中间字符，从这个中间字符向下、向左上（45度）、向右上（45度）的字符都与中间的字符相同。<br>　　字母 Y 的长度指同时向 3 个方向的相同字母延伸的最大距离。<br>　　例如，下图中所有的 1 组成一个字母 Y，长度为 3。<br>　　又如，下图中以第 5 行第 6 列为中心也构成一个字母 Y （由字符 A 构成），长度为 1 。<br>　　再如，下图中以第 4 行第 3 列为中心也构成一个字母 Y （由字符 0 构成），长度为 2 。</p><p>　　1000001<br>　　0100010<br>　　0010100<br>　　0001AAA<br>　　00010A0<br>　　00010A0<br>　　00010A0<br>给定一个字符矩阵，请找出能构成字母 Y 的最大长度，如果无法构成字母 Y，请输出 0 。</p><p>【输入格式】</p><p>　　输入的第一行包含两个整数 n, m ，用一个空格分隔，表示字符矩阵的行数和列数。<br>　　接下来 n 行，每行包含 m 个字符，表示字符矩阵。</p><p>【输出格式】</p><p>　　输出一行包含一个整数，表示答案。</p><p>输入样例：</p><p>7 7<br>1000001<br>0100010<br>0010100<br>0001AAA<br>00010A0<br>00010A0<br>00010A0<br>输出样例：</p><p>3<br>【评测用例规模与约定】</p><p>　　对于50%的评测用例，1 &lt;&#x3D; n, m &lt;&#x3D; 100。<br>　　对于所有评测用例，1 &lt;&#x3D; n, m &lt;&#x3D; 1000，字符矩阵中仅包含数字字符和大写英文字母。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1005;</span><br><span class="line"></span><br><span class="line">char a[N][N];</span><br><span class="line">int n,m,sum1,sum2,sum3,max_;</span><br><span class="line">void dfs1(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">if(x&lt;0||x&gt;=n||y&lt;0||y&gt;=m||a[x][y]!=a[x+1][y+1]) return ;</span><br><span class="line">sum1++;</span><br><span class="line">dfs1(x-1,y-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs2(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">if(x&lt;0||x&gt;=n||y&lt;0||y&gt;=m||a[x][y]!=a[x+1][y-1]) return ;</span><br><span class="line">sum2++;</span><br><span class="line">dfs2(x-1,y+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs3(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">if(x&lt;0||x&gt;=n||y&lt;0||y&gt;=m||a[x][y]!=a[x-1][y]) return ;</span><br><span class="line">sum3++;</span><br><span class="line">dfs3(x+1,y);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">int min_ = 0x3f3f3f3f;</span><br><span class="line">sum1=sum2=sum3=0;</span><br><span class="line">if(i-1&lt;0||j-1&lt;0||j+1&gt;=m||i+1&gt;=n) continue;</span><br><span class="line">if(a[i][j]!=a[i-1][j-1]||a[i][j]!=a[i-1][j+1]||a[i][j]!=a[i+1][j]) continue;</span><br><span class="line">dfs1(i-1,j-1);</span><br><span class="line">dfs2(i-1,j+1);</span><br><span class="line">dfs3(i+1,j);</span><br><span class="line">min_=min(min_,sum1);</span><br><span class="line">min_=min(min_,sum2);</span><br><span class="line">min_=min(min_,sum3);</span><br><span class="line">max_=max(max_,min_);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; max_;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过河卒</title>
      <link href="/2024/03/05/%E8%BF%87%E6%B2%B3%E5%8D%92/"/>
      <url>/2024/03/05/%E8%BF%87%E6%B2%B3%E5%8D%92/</url>
      
        <content type="html"><![CDATA[<h1 id="NOIP2002-普及组-过河卒"><a href="#NOIP2002-普及组-过河卒" class="headerlink" title="[NOIP2002 普及组] 过河卒"></a>[NOIP2002 普及组] 过河卒</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。</p><p>棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ipmwl52i.png"></p><p>现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行四个正整数，分别表示 $B$ 点坐标和马的坐标。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示所有的路径条数。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 6 3 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于 $100 %$ 的数据，$1 \le n, m \le 20$，$0 \le$ 马的坐标 $\le 20$。</p><p><strong>【题目来源】</strong></p><p>NOIP 2002 普及组第四题</p><p>根据象棋规则，卒只能往下或往右，再根据棋盘，很容易想到开一个二维数组来解决。</p><p>可以先不考虑马的位置，只判断到B点坐标的位置，进行移动，再对二维数组进行遍历查找，找到到B点的路线。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[30][30]=1；</span><br><span class="line">int n,m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;//B点坐标</span><br><span class="line">for(int i=0;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;i&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line">a[i][j]=a[i-1]+a[i][j-1];//卒的移动规则来相加判断路线</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组先所有赋值1，接下来判断特例。在n&#x3D;0时或m&#x3D;0时路线有且仅有1条,或者b点坐标在(0,0)时，也是一条</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[30][30]=1；</span><br><span class="line">int n,m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;//B点坐标</span><br><span class="line">for(int i=0;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;i&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(i==0)</span><br><span class="line">&#123;</span><br><span class="line">a[i][j]=a[i]+a[j-1];</span><br><span class="line">&#125;</span><br><span class="line">else if(j==0)</span><br><span class="line">&#123;</span><br><span class="line">a[i][j]=a[i-1]+a[j];</span><br><span class="line">&#125;</span><br><span class="line">a[i][j]=a[i-1]+a[i][j-1];//卒的移动规则来相加判断路线</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; a[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，不考虑马的情况下的话，已经可以计算出A到B点的路径数了。接下来把马的位置考虑上，马的位置的话有8个特殊点，需要将8个特殊点及马本身判为0，并且需要考虑8个特殊点是否会越界。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[x][y] = 0;</span><br><span class="line">if (x + 2 &lt;= n &amp;&amp; y - 1 &gt;= 0)</span><br><span class="line">    a[x + 2][y - 1] = 0;</span><br><span class="line">if (x + 2 &lt;= n &amp;&amp; y + 1 &lt;= m)</span><br><span class="line">    a[x + 2][y + 1] = 0;</span><br><span class="line">if (x + 1 &lt;= n &amp;&amp; y + 2 &lt;= m)</span><br><span class="line">    a[x + 1][y + 2] = 0;</span><br><span class="line">if (x - 1 &gt;= 0 &amp;&amp; y + 2 &lt;= m)</span><br><span class="line">    a[x - 1][y + 2] = 0;</span><br><span class="line">if (x - 2 &gt;= 0 &amp;&amp; y + 1 &lt;= m)</span><br><span class="line">    a[x - 2][y + 1] = 0;</span><br><span class="line">if (x - 2 &gt;= 0 &amp;&amp; y - 1 &gt;= 0)</span><br><span class="line">    a[x - 2][y - 1] = 0;</span><br><span class="line">if (x - 1 &gt;= 0 &amp;&amp; y - 2 &gt;= 0)</span><br><span class="line">    a[x - 1][y - 2] = 0;</span><br><span class="line">if (x + 1 &lt;= n &amp;&amp; y - 2 &gt;= 0)</span><br><span class="line">    a[x + 1][y - 2] = 0;</span><br></pre></td></tr></table></figure><p>将马及马的位置判断出来后，加入到代码中，就有如下代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long int a[30][30] = &#123;0&#125;;</span><br><span class="line">    int n, m, x, y;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    for (int i = 0; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][j] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[x][y] = 0;</span><br><span class="line">    if (x + 2 &lt;= n &amp;&amp; y - 1 &gt;= 0)</span><br><span class="line">        a[x + 2][y - 1] = 0;</span><br><span class="line">    if (x + 2 &lt;= n &amp;&amp; y + 1 &lt;= m)</span><br><span class="line">        a[x + 2][y + 1] = 0;</span><br><span class="line">    if (x + 1 &lt;= n &amp;&amp; y + 2 &lt;= m)</span><br><span class="line">        a[x + 1][y + 2] = 0;</span><br><span class="line">    if (x - 1 &gt;= 0 &amp;&amp; y + 2 &lt;= m)</span><br><span class="line">        a[x - 1][y + 2] = 0;</span><br><span class="line">    if (x - 2 &gt;= 0 &amp;&amp; y + 1 &lt;= m)</span><br><span class="line">        a[x - 2][y + 1] = 0;</span><br><span class="line">    if (x - 2 &gt;= 0 &amp;&amp; y - 1 &gt;= 0)</span><br><span class="line">        a[x - 2][y - 1] = 0;</span><br><span class="line">    if (x - 1 &gt;= 0 &amp;&amp; y - 2 &gt;= 0)</span><br><span class="line">        a[x - 1][y - 2] = 0;</span><br><span class="line">    if (x + 1 &lt;= n &amp;&amp; y - 2 &gt;= 0)</span><br><span class="line">        a[x + 1][y - 2] = 0;</span><br><span class="line">    for (int i = 0; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (i == 0 &amp;&amp; j == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (a[i][j] == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (i == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i][j] = a[i][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            else if (j == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i][j] = a[i - 1][j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                a[i][j] = a[i - 1][j] + a[i][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; a[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算竞常用_C++_STL_用法</title>
      <link href="/2024/03/02/%E7%AE%97%E7%AB%9E%E5%B8%B8%E7%94%A8_C++_STL_%E7%94%A8%E6%B3%95/"/>
      <url>/2024/03/02/%E7%AE%97%E7%AB%9E%E5%B8%B8%E7%94%A8_C++_STL_%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>**C++ 标准模板库 (STL, Standard Template Library)**：包含一些常用数据结构与算法的模板的 C++ 软件库。其包含四个组件——算法 (Algorithms)、容器 (Containers)、仿函数 (Functors)、迭代器 (Iterators).</p><span id="more"></span><p>示例：</p><ul><li>算法：<code>sort(a.begin(), a.end())</code></li><li>容器：<code>priority_queue&lt;int&gt; pque</code></li><li>仿函数：<code>greater&lt;int&gt;()</code></li><li>迭代器：<code>vector&lt;int&gt;::iterator it = a.begin()</code></li></ul><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>STL 作为一个封装良好，性能合格的 C++ 标准库，在算法竞赛中运用极其常见。灵活且正确使用 STL 可以节省非常多解题时间，这一点不仅是由于可以直接调用，还是因为它封装良好，可以让代码的可读性变高，解题思路更清晰，调试过程 <del>往往</del> 更顺利。</p><p>不过 STL 毕竟使用了很多复杂的结构来实现丰富的功能，它的效率往往是比不上自己手搓针对特定题目的数据结构与算法的。因此，STL 的使用相当于使用更长的运行时间换取更高的编程效率。因此，在实际比赛中要权衡 STL 的利弊，不过这一点就得靠经验了。</p><p>接下来，我会分享在算法竞赛中常用的 STL 容器和算法，对于函数和迭代器，就不着重展开讲了。</p><h1 id="2-常用容器"><a href="#2-常用容器" class="headerlink" title="2 常用容器"></a>2 常用容器</h1><h2 id="2-1-内容总览"><a href="#2-1-内容总览" class="headerlink" title="2.1 内容总览"></a>2.1 内容总览</h2><p>打勾的是本次将会详细讲解的，加粗的是算法竞赛中有必要学习的。</p><ul><li><p>顺序容器</p><ul><li><p><input disabled type="checkbox"> <strong>array</strong></p></li><li><p><input checked disabled type="checkbox"> <strong>vector</strong></p></li><li><p><input disabled type="checkbox"> <strong>deque</strong></p></li><li><p><input disabled type="checkbox"> forward_list</p></li><li><p><input disabled type="checkbox"> <strong>list</strong></p></li></ul></li><li><p>关联容器</p><ul><li><input checked disabled type="checkbox"> <strong>set</strong></li><li><input checked disabled type="checkbox"> <strong>map</strong></li><li><input disabled type="checkbox"> <strong>multiset</strong></li><li><input disabled type="checkbox"> <strong>multimap</strong></li></ul></li><li><p>无序关联容器</p><ul><li><input disabled type="checkbox"> <strong>unordered_set</strong></li><li><input disabled type="checkbox"> <strong>unordered_map</strong></li><li><input disabled type="checkbox"> <strong>unordered_multiset</strong></li><li><input disabled type="checkbox"> <strong>unordered_multimap</strong></li></ul></li><li><p>容器适配器</p><ul><li><input checked disabled type="checkbox"> <strong>stack</strong></li><li><input checked disabled type="checkbox"> <strong>queue</strong></li><li><input checked disabled type="checkbox"> <strong>priority_queue</strong></li><li><input disabled type="checkbox"> flat_set</li><li><input disabled type="checkbox"> flat_map</li><li><input disabled type="checkbox"> flat_multiset</li><li><input disabled type="checkbox"> flat_multimap</li></ul></li><li><p>字符串</p><ul><li><input checked disabled type="checkbox"> <strong>string</strong> (basic_string&lt;char&gt;)</li></ul></li><li><p>对与元组</p><ul><li><input checked disabled type="checkbox"> <strong>pair</strong></li><li><input disabled type="checkbox"> <strong>tuple</strong></li></ul></li></ul><h2 id="2-2-向量-vector"><a href="#2-2-向量-vector" class="headerlink" title="2.2 向量 vector"></a>2.2 向量 <a href="https://zh.cppreference.com/w/cpp/container/vector">vector</a></h2><p><strong><code>#include &lt;vector&gt;</code></strong></p><p>连续的顺序的储存结构（和数组一样的类别），但是有长度可变的特性。</p><h3 id="2-2-1-常用方法"><a href="#2-2-1-常用方法" class="headerlink" title="2.2.1 常用方法"></a>2.2.1 常用方法</h3><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p><strong><code>vector&lt;类型&gt; arr(长度, [初值])</code></strong></p><p>时间复杂度：$O(n)$</p><p>常用的一维和二维数组构造示例，高维也是一样的（就是会有点长）.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr;         <span class="comment">// 构造int数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>)</span></span>;    <span class="comment">// 构造初始长100的int数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 构造初始长100的int数组，初值为1</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mat</span>(<span class="number">100</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ());       <span class="comment">// 构造初始100行，不指定列数的二维数组</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mat</span>(<span class="number">100</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (<span class="number">666</span>, <span class="number">-1</span>)) <span class="comment">// 构造初始100行，初始666列的二维数组，初值为-1</span></span><br></pre></td></tr></table></figure><p>构造二维数组的奇葩写法，千万别用：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr[<span class="number">100</span>];         <span class="comment">// 正确，构造初始100行，不指定列数的二维数组，可用于链式前向星存图</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr[<span class="number">100</span>](<span class="number">100</span>, <span class="number">1</span>); <span class="comment">// 语法错误！</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span>[100]</span>; <span class="comment">// 语法错误！</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr[<span class="number">100</span>] &#123;&#123;<span class="number">100</span>, <span class="number">1</span>&#125;, 这里省略<span class="number">98</span>个 ,&#123;<span class="number">100</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">// 正确但奇葩，使用列表初始化</span></span><br></pre></td></tr></table></figure><h4 id="尾接-尾删"><a href="#尾接-尾删" class="headerlink" title="尾接 &amp; 尾删"></a>尾接 &amp; 尾删</h4><ul><li>**<code>.push_back(元素)</code>**：在 vector 尾接一个元素，数组长度 $+1$.</li><li>**<code>.pop_back()</code>**：删除 vector 尾部的一个元素，数组长度 $-1$</li></ul><p>时间复杂度：均摊 $O(1)$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// init: arr = []</span></span><br><span class="line">arr.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// after: arr = [1]</span></span><br><span class="line">arr.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// after: arr = [1, 2]</span></span><br><span class="line">arr.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">// after: arr = [1]</span></span><br><span class="line">arr.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">// after: arr = []</span></span><br></pre></td></tr></table></figure><h4 id="中括号运算符"><a href="#中括号运算符" class="headerlink" title="中括号运算符"></a>中括号运算符</h4><p>和一般数组一样的作用</p><p>时间复杂度：$O(1)$</p><h4 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h4><p><strong><code>.size()</code></strong></p><p>获取当前 vector 的长度</p><p>时间复杂度：$O(1)$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h4><p><strong><code>.clear()</code></strong></p><p>清空 vector</p><p>时间复杂度：$O(n)$</p><h4 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h4><p><strong><code>.empty()</code></strong></p><p>如果是空返回 <code>true</code> 反之返回 <code>false</code>.</p><p>时间复杂度：$O(1)$</p><h4 id="改变长度"><a href="#改变长度" class="headerlink" title="改变长度"></a>改变长度</h4><p><strong><code>.resize(新长度, [默认值])</code></strong></p><p>修改 vector 的长度</p><ul><li>如果是缩短，则删除多余的值</li><li>如果是扩大，且指定了默认值，则新元素均为默认值<strong>（旧元素不变）</strong></li></ul><p>时间复杂度：$O(n)$</p><h3 id="2-2-2-适用情形"><a href="#2-2-2-适用情形" class="headerlink" title="2.2.2 适用情形"></a>2.2.2 适用情形</h3><p>一般情况 <code>vector</code> 可以替换掉普通数组，除非该题卡常。</p><p>有些情况普通数组没法解决：$n\times m$ 的矩阵，$1\leq n,m\leq 10^6$ 且 $n\times m \leq 10^6$</p><ul><li>如果用普通数组 <code>int mat[1000010][1000010]</code>，浪费内存，会导致 MLE。</li><li>如果使用 <code>vector&lt;vector&lt;int&gt;&gt; mat(n + 10, vector&lt;int&gt; (m + 10))</code>，完美解决该问题。</li></ul><p>另外，<code>vector</code> 的数据储存在堆空间中，不会爆栈。</p><h3 id="2-2-3-注意事项"><a href="#2-2-3-注意事项" class="headerlink" title="2.2.3 注意事项"></a>2.2.3 注意事项</h3><h4 id="提前指定长度"><a href="#提前指定长度" class="headerlink" title="提前指定长度"></a>提前指定长度</h4><p>如果长度已经确定，那么应当直接在构造函数指定长度，而不是一个一个 <code>.push_back()</code>. 因为 <code>vector</code> 额外内存耗尽后的重分配是有时间开销的，直接指定长度就不会出现重分配了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优化前: 522ms</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; i++)</span><br><span class="line">    a.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="comment">// 优化后: 259ms</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1e8</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    a[i] = i;</span><br></pre></td></tr></table></figure><h4 id="当心-size-t-溢出"><a href="#当心-size-t-溢出" class="headerlink" title="当心 size_t 溢出"></a>当心 size_t 溢出</h4><p>vector 获取长度的方法 <code>.size()</code> 返回值类型为 <code>size_t</code>，通常 OJ 平台使用的是 32 位编译器（有些平台例如 cf 可选 64 位），那么该类型范围为 $[0,2^{32})$.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">65536</span>)</span></span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a = a.<span class="built_in">size</span>() * a.<span class="built_in">size</span>(); <span class="comment">// 直接溢出变成0了</span></span><br></pre></td></tr></table></figure><h2 id="2-3-栈-stack"><a href="#2-3-栈-stack" class="headerlink" title="2.3 栈 stack"></a>2.3 栈 <a href="https://zh.cppreference.com/w/cpp/container/stack">stack</a></h2><p><strong><code>#include &lt;stack&gt;</code></strong></p><p>通过二次封装双端队列 (deque) 容器，实现先进后出的栈数据结构。</p><h3 id="2-3-1-常用方法"><a href="#2-3-1-常用方法" class="headerlink" title="2.3.1 常用方法"></a>2.3.1 常用方法</h3><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>构造</td><td><code>stack&lt;类型&gt; stk</code></td><td><code>stack&lt;int&gt; stk;</code></td></tr><tr><td>进栈</td><td><code>.push(元素)</code></td><td><code>stk.push(1);</code></td></tr><tr><td>出栈</td><td><code>.pop()</code></td><td><code>stk.pop();</code></td></tr><tr><td>取栈顶</td><td><code>.top()</code></td><td><code>int a = stk.top();</code></td></tr><tr><td>查看大小 &#x2F; 清空 &#x2F; 判空</td><td>略</td><td>略</td></tr></tbody></table><h3 id="2-3-2-适用情形"><a href="#2-3-2-适用情形" class="headerlink" title="2.3.2 适用情形"></a>2.3.2 适用情形</h3><p>如果不卡常的话，就可以直接用它而不需要手写栈了。</p><p>另外，vector 也可以当栈用，vector 的 <code>.back()</code> 取尾部元素，就相当于取栈顶，<code>.push_back()</code> 相当于进栈，<code>.pop_back()</code> 相当于出栈。</p><h3 id="2-3-3-注意事项"><a href="#2-3-3-注意事项" class="headerlink" title="2.3.3 注意事项"></a>2.3.3 注意事项</h3><p>不可访问内部元素！<strong>下面都是错误用法</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stk.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; stk[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ele : stk)</span><br><span class="line">    cout &lt;&lt; stk &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="2-4-队列-queue"><a href="#2-4-队列-queue" class="headerlink" title="2.4 队列 queue"></a>2.4 队列 <a href="https://zh.cppreference.com/w/cpp/container/queue">queue</a></h2><p><strong><code>#include &lt;queue&gt;</code></strong></p><p>通过二次封装双端队列 (deque) 容器，实现先进先出的队列数据结构。</p><h3 id="2-4-1-常用方法"><a href="#2-4-1-常用方法" class="headerlink" title="2.4.1 常用方法"></a>2.4.1 常用方法</h3><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>构造</td><td><code>queue&lt;类型&gt; que</code></td><td><code>queue&lt;int&gt; que;</code></td></tr><tr><td>进队</td><td><code>.push(元素)</code></td><td><code>que.push(1);</code></td></tr><tr><td>出队</td><td><code>.pop()</code></td><td><code>que.pop();</code></td></tr><tr><td>取队首</td><td><code>.front()</code></td><td><code>int a = que.front();</code></td></tr><tr><td>取队尾</td><td><code>.back()</code></td><td><code>int a = que.back();</code></td></tr><tr><td>查看大小 &#x2F; 清空 &#x2F; 判空</td><td>略</td><td>略</td></tr></tbody></table><h3 id="2-4-2-适用情形"><a href="#2-4-2-适用情形" class="headerlink" title="2.4.2 适用情形"></a>2.4.2 适用情形</h3><p>如果不卡常的话，就可以直接用它而不需要手写队列了。</p><h3 id="2-4-3-注意事项"><a href="#2-4-3-注意事项" class="headerlink" title="2.4.3 注意事项"></a>2.4.3 注意事项</h3><p>不可访问内部元素！<strong>下面都是错误用法</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; que.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; que[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ele : que)</span><br><span class="line">    cout &lt;&lt; ele &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="2-5-优先队列-priority-queue"><a href="#2-5-优先队列-priority-queue" class="headerlink" title="2.5 优先队列 priority_queue"></a>2.5 优先队列 <a href="https://zh.cppreference.com/w/cpp/container/priority_queue">priority_queue</a></h2><p><strong><code>#include &lt;queue&gt;</code></strong></p><p>提供常数时间的最大元素查找，对数时间的插入与提取，底层原理是二叉堆。</p><h3 id="2-5-1-常用方法"><a href="#2-5-1-常用方法" class="headerlink" title="2.5.1 常用方法"></a>2.5.1 常用方法</h3><h4 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h4><p><strong><code>priority_queue&lt;类型, 容器, 比较器&gt; pque</code></strong></p><ul><li>类型：要储存的数据类型</li><li>容器：储存数据的底层容器，默认为 <code>vector&lt;类型&gt;</code>，竞赛中保持默认即可</li><li>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pque1;                            <span class="comment">// 储存int的大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pque2; <span class="comment">// 储存int的小顶堆</span></span><br></pre></td></tr></table></figure><blockquote><p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 &#x2F; lambda 表达式），在此就不展开讲了。如果想要了解，可以查阅 cppreference 中的代码示例。</p></blockquote><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>进堆</td><td><code>.push(元素)</code></td><td><code>que.push(1);</code></td></tr><tr><td>出堆</td><td><code>.pop()</code></td><td><code>que.pop();</code></td></tr><tr><td>取堆顶</td><td><code>.top()</code></td><td><code>int a = que.top();</code></td></tr><tr><td>查看大小 &#x2F; 判空</td><td>略</td><td>略</td></tr></tbody></table><p>进出队复杂度 $O(\log n)$，取堆顶 $O(1)$.</p><h3 id="2-5-2-适用情形"><a href="#2-5-2-适用情形" class="headerlink" title="2.5.2 适用情形"></a>2.5.2 适用情形</h3><p>持续维护元素的有序性：每次向队列插入大小不定的元素，或者每次从队列里取出大小最小&#x2F;最大的元素，元素数量 $n$，插入操作数量 $k$.</p><ul><li>每次插入后进行快速排序：$k\cdot n\log n$</li><li>使用优先队列维护：$k\cdot\log n$</li></ul><h3 id="2-5-3-注意事项"><a href="#2-5-3-注意事项" class="headerlink" title="2.5.3 注意事项"></a>2.5.3 注意事项</h3><h4 id="仅堆顶可读"><a href="#仅堆顶可读" class="headerlink" title="仅堆顶可读"></a>仅堆顶可读</h4><p>只可访问堆顶，其他元素都无法读取到。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; pque[<span class="number">1</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="所有元素不可写"><a href="#所有元素不可写" class="headerlink" title="所有元素不可写"></a>所有元素不可写</h4><p>堆中所有元素是不可修改的。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pque[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">pque.<span class="built_in">top</span>() = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果你恰好要修改的是堆顶元素，那么是可以完成的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tp = pque.<span class="built_in">top</span>();</span><br><span class="line">pque.<span class="built_in">pop</span>();</span><br><span class="line">pque.<span class="built_in">push</span>(tp + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="2-6-集合-set"><a href="#2-6-集合-set" class="headerlink" title="2.6 集合 set"></a>2.6 集合 <a href="https://zh.cppreference.com/w/cpp/container/set">set</a></h2><p><strong><code>#include &lt;set&gt;</code></strong></p><p>提供对数时间的插入、删除、查找的集合数据结构。底层原理是红黑树。</p><table><thead><tr><th>集合三要素</th><th>解释</th><th>set</th><th>multiset</th><th>unordered_set</th></tr></thead><tbody><tr><td>确定性</td><td>一个元素要么在集合中，要么不在</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>互异性</td><td>一个元素仅可以在集合中出现一次</td><td>✔</td><td>❌（任意次）</td><td>✔</td></tr><tr><td>无序性</td><td>集合中的元素是没有顺序的</td><td>❌（从小到大）</td><td>❌（从小到大）</td><td>✔</td></tr></tbody></table><h3 id="2-6-1-常用方法"><a href="#2-6-1-常用方法" class="headerlink" title="2.6.1 常用方法"></a>2.6.1 常用方法</h3><h4 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h4><p><strong><code>set&lt;类型, 比较器&gt; st</code></strong></p><ul><li>类型：要储存的数据类型</li><li>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; st1;               <span class="comment">// 储存int的集合（从小到大）</span></span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; st2; <span class="comment">// 储存int的集合（从大到小）</span></span><br></pre></td></tr></table></figure><blockquote><p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 &#x2F; lambda 表达式），在此就不展开讲了。</p></blockquote><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>可使用迭代器进行遍历：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>基于范围的循环（C++ 11）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ele : st)</span><br><span class="line">    cout &lt;&lt; ele &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>插入元素</td><td><code>.insert(元素)</code></td><td><code>st.insert(1);</code></td></tr><tr><td>删除元素</td><td><code>.erase(元素)</code></td><td><code>st.erase(2);</code></td></tr><tr><td>查找元素</td><td><code>.find(元素)</code></td><td><code>auto it = st.find(1);</code></td></tr><tr><td>判断元素是否存在</td><td><code>.count(元素)</code></td><td><code>st.count(3);</code></td></tr><tr><td>查看大小 &#x2F; 清空 &#x2F; 判空</td><td>略</td><td>略</td></tr></tbody></table><p>增删查时间复杂度均为 $O(\log n)$</p><h3 id="2-6-2-适用情形"><a href="#2-6-2-适用情形" class="headerlink" title="2.6.2 适用情形"></a>2.6.2 适用情形</h3><ul><li>元素去重：$[1,1,3,2,4,4]\to[1,2,3,4]$</li><li>维护顺序：$[1,5,3,7,9]\to[1,3,5,7,9]$</li><li>元素是否出现过：元素大小 $[-10^{18},10^{18}]$，元素数量 $10^6$，vis 数组无法实现，通过 set 可以完成。</li></ul><h3 id="2-6-3-注意事项"><a href="#2-6-3-注意事项" class="headerlink" title="2.6.3 注意事项"></a>2.6.3 注意事项</h3><h4 id="不存在下标索引"><a href="#不存在下标索引" class="headerlink" title="不存在下标索引"></a>不存在下标索引</h4><p>set 虽说可遍历，但仅可使用迭代器进行遍历，它不存在下标这一概念，无法通过下标访问到数据。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; st[<span class="number">0</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="元素只读"><a href="#元素只读" class="headerlink" title="元素只读"></a>元素只读</h4><p>set 的迭代器取到的元素是只读的（因为是 const 迭代器），不可修改其值。如果要改，需要先 erase 再 insert. <strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; *st.<span class="built_in">begin</span>() &lt;&lt; endl; <span class="comment">// 正确。可读。</span></span><br><span class="line">*st.<span class="built_in">begin</span>() = <span class="number">1</span>;             <span class="comment">// 错误！不可写！</span></span><br></pre></td></tr></table></figure><h4 id="不可用迭代器计算下标"><a href="#不可用迭代器计算下标" class="headerlink" title="不可用迭代器计算下标"></a>不可用迭代器计算下标</h4><p>set 的迭代器不能像 vector 一样相减得到下标。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = st.<span class="built_in">find</span>(<span class="number">2</span>);      <span class="comment">// 正确，返回2所在位置的迭代器。</span></span><br><span class="line"><span class="type">int</span> idx = it - st.<span class="built_in">begin</span>(); <span class="comment">// 错误！不可相减得到下标。</span></span><br></pre></td></tr></table></figure><h2 id="2-7-映射-map"><a href="#2-7-映射-map" class="headerlink" title="2.7 映射 map"></a>2.7 映射 <a href="https://zh.cppreference.com/w/cpp/container/map">map</a></h2><p><strong><code>#include &lt;map&gt;</code></strong></p><p>提供对数时间的有序键值对结构。底层原理是红黑树。</p><p>映射：<br>$$<br>\begin{matrix}<br>1&amp;\to&amp;2\<br>2&amp;\to&amp;2\<br>3&amp;\to&amp;1\<br>4&amp;\to&amp;5\<br>&amp;\vdots<br>\end{matrix}<br>$$</p><table><thead><tr><th>性质</th><th>解释</th><th>map</th><th>multimap</th><th>unordered_map</th></tr></thead><tbody><tr><td>互异性</td><td>一个键仅可以在映射中出现一次</td><td>✔</td><td>❌（任意次）</td><td>✔</td></tr><tr><td>无序性</td><td>键是没有顺序的</td><td>❌（从小到大）</td><td>❌（从小到大）</td><td>✔</td></tr></tbody></table><h3 id="2-7-1-常用方法"><a href="#2-7-1-常用方法" class="headerlink" title="2.7.1 常用方法"></a>2.7.1 常用方法</h3><h4 id="构造-3"><a href="#构造-3" class="headerlink" title="构造"></a>构造</h4><p><strong><code>map&lt;键类型, 值类型, 比较器&gt; mp</code></strong></p><ul><li>键类型：要储存键的数据类型</li><li>值类型：要储存值的数据类型</li><li>比较器：键比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp1;               <span class="comment">// int-&gt;int 的映射（键从小到大）</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; st2; <span class="comment">// int-&gt;int 的映射（键从大到小）</span></span><br></pre></td></tr></table></figure><blockquote><p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 &#x2F; lambda 表达式），在此就不展开讲了。</p></blockquote><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><p>可使用迭代器进行遍历：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>基于范围的循环（C++ 11）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pr : mp)</span><br><span class="line">    cout &lt;&lt; pr.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; pr.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>结构化绑定 + 基于范围的循环（C++17）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[key, val] : mp)</span><br><span class="line">    cout &lt;&lt; key &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h4><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>增 &#x2F; 改 &#x2F; 查元素</td><td>中括号</td><td><code>mp[1] = 2;</code></td></tr><tr><td>查元素（返回迭代器）</td><td><code>.find(元素)</code></td><td><code>auto it = mp.find(1);</code></td></tr><tr><td>删除元素</td><td><code>.erase(元素)</code></td><td><code>mp.erase(2);</code></td></tr><tr><td>判断元素是否存在</td><td><code>.count(元素)</code></td><td><code>mp.count(3);</code></td></tr><tr><td>查看大小 &#x2F; 清空 &#x2F; 判空</td><td>略</td><td>略</td></tr></tbody></table><p>增删改查时间复杂度均为 $O(\log n)$</p><h3 id="2-7-2-适用情形"><a href="#2-7-2-适用情形" class="headerlink" title="2.7.2 适用情形"></a>2.7.2 适用情形</h3><p>需要维护映射的场景可以使用：输入若干字符串，统计每种字符串的出现次数。(<code>map&lt;string, int&gt; mp</code>)</p><h3 id="2-7-3-注意事项"><a href="#2-7-3-注意事项" class="headerlink" title="2.7.3 注意事项"></a>2.7.3 注意事项</h3><h4 id="中括号访问时默认值"><a href="#中括号访问时默认值" class="headerlink" title="中括号访问时默认值"></a>中括号访问时默认值</h4><p>如果使用中括号访问 map 时对应的键不存在，那么会新增这个键，并且值为默认值，因此中括号会影响键的存在性。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">cout &lt;&lt; mp.<span class="built_in">count</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>];                       <span class="comment">// 即使什么都没做，此时mp[&#x27;a&#x27;]=0已经插入了</span></span><br><span class="line">cout &lt;&lt; mp.<span class="built_in">count</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; mp[<span class="string">&#x27;a&#x27;</span>] &lt;&lt; endl;       <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h4 id="不可用迭代器计算下标-1"><a href="#不可用迭代器计算下标-1" class="headerlink" title="不可用迭代器计算下标"></a>不可用迭代器计算下标</h4><p>map 的迭代器不能像 vector 一样相减得到下标。<strong>下面是错误用法：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>);      <span class="comment">// 正确，返回2所在位置的迭代器。</span></span><br><span class="line"><span class="type">int</span> idx = it - mp.<span class="built_in">begin</span>();   <span class="comment">// 错误！不可相减得到下标。</span></span><br></pre></td></tr></table></figure><h2 id="2-8-字符串-string"><a href="#2-8-字符串-string" class="headerlink" title="2.8 字符串 string"></a>2.8 字符串 <a href="https://zh.cppreference.com/w/cpp/string">string</a></h2><p><strong><code>#include &lt;string&gt;</code></strong></p><p>顾名思义，就是储存字符串的。</p><h3 id="2-8-1-常用方法"><a href="#2-8-1-常用方法" class="headerlink" title="2.8.1 常用方法"></a>2.8.1 常用方法</h3><h4 id="构造-4"><a href="#构造-4" class="headerlink" title="构造"></a>构造</h4><p>构造函数：<code>string(长度, 初值)</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1;           <span class="comment">// 构造字符串，为空</span></span><br><span class="line">string s2 = <span class="string">&quot;awa!&quot;</span>;  <span class="comment">// 构造字符串，并赋值awa!</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;6&#x27;</span>)</span></span>;  <span class="comment">// 构造字符串，通过构造函数构造为6666666666</span></span><br></pre></td></tr></table></figure><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><p>C++</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">cout &lt;&lt; s;</span><br></pre></td></tr></table></figure><p>C</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;buf);</span><br><span class="line">s = buf;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><h4 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a>其他</h4><table><thead><tr><th>作用</th><th>用法</th><th>示例</th></tr></thead><tbody><tr><td>修改、查询指定下标字符</td><td><code>[]</code></td><td><code>s[1] = &#39;a&#39;;</code></td></tr><tr><td>是否相同</td><td><code>==</code></td><td><code>if (s1 == s2) ...</code></td></tr><tr><td>字符串连接</td><td><code>+</code></td><td><code>string s = s1 + s2;</code></td></tr><tr><td>尾接字符串</td><td><code>+=</code></td><td><code>s += &quot;awa&quot;;</code></td></tr><tr><td>取子串</td><td><code>.substr(起始下标, 子串长度)</code></td><td><code>string sub = s.substr(2, 10);</code></td></tr><tr><td>查找字符串</td><td><code>.find(字符串, 起始下标)</code></td><td><code>int pos = s.find(&quot;awa&quot;);</code></td></tr></tbody></table><h4 id="数值与字符串互转（C-11）"><a href="#数值与字符串互转（C-11）" class="headerlink" title="数值与字符串互转（C++11）"></a>数值与字符串互转（C++11）</h4><table><thead><tr><th>源</th><th>目的</th><th>函数</th></tr></thead><tbody><tr><td>int &#x2F; long long &#x2F; float &#x2F; double &#x2F; long double</td><td>string</td><td>to_string()</td></tr><tr><td>string</td><td>int</td><td>stoi()</td></tr><tr><td>string</td><td>long long</td><td>stoll()</td></tr><tr><td>string</td><td>float</td><td>stof()</td></tr><tr><td>string</td><td>double</td><td>stod()</td></tr><tr><td>string</td><td>long double</td><td>stold()</td></tr></tbody></table><h3 id="2-8-2-适用情形"><a href="#2-8-2-适用情形" class="headerlink" title="2.8.2 适用情形"></a>2.8.2 适用情形</h3><p>非常好用！<del>建议直接把字符数组扔了，赶快投入 string 的怀抱。</del></p><h3 id="2-8-3-注意事项"><a href="#2-8-3-注意事项" class="headerlink" title="2.8.3 注意事项"></a>2.8.3 注意事项</h3><h4 id="尾接字符串一定要用"><a href="#尾接字符串一定要用" class="headerlink" title="尾接字符串一定要用 +="></a>尾接字符串一定要用 <code>+=</code></h4><p>string 的 +&#x3D; 运算符，将会在原字符串原地尾接字符串。而 + 了再 &#x3D; 赋值，会先生成一个临时变量，在复制给 string.</p><p>通常字符串长度可以很长，如果使用 + 字符串很容易就 TLE 了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优化前: 15139ms</span></span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5e5</span>; i++)</span><br><span class="line">    s = s + <span class="string">&quot;a&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后: &lt; 1ms (计时器显示0)</span></span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5e5</span>; i++)</span><br><span class="line">    s += <span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="substr-方法的奇葩参数"><a href="#substr-方法的奇葩参数" class="headerlink" title=".substr() 方法的奇葩参数"></a><code>.substr()</code> 方法的奇葩参数</h4><p>一定要注意，C++ string 的取子串的第一个参数是<strong>子串起点下标</strong>，第二个参数是<strong>子串长度</strong>。</p><p>第二个参数不是子串终点！不是子串终点！要与 java 等其他语言区分开来。</p><h4 id="find-方法的复杂度"><a href="#find-方法的复杂度" class="headerlink" title=".find() 方法的复杂度"></a><code>.find()</code> 方法的复杂度</h4><p>该方法实现为暴力实现，时间复杂度为 $O(n^2)$.</p><p><del>不要幻想 STL 内置了个 $O(n)$ 的 KMP 算法</del></p><h2 id="2-9-二元组-pair"><a href="#2-9-二元组-pair" class="headerlink" title="2.9 二元组 pair"></a>2.9 二元组 <a href="https://zh.cppreference.com/w/cpp/utility/pair">pair</a></h2><p><strong><code>#include &lt;utility&gt;</code></strong></p><p>顾名思义，就是储存二元组的。</p><h3 id="2-9-1-常用方法"><a href="#2-9-1-常用方法" class="headerlink" title="2.9.1 常用方法"></a>2.9.1 常用方法</h3><h4 id="构造-5"><a href="#构造-5" class="headerlink" title="构造"></a>构造</h4><p><strong><code>pair&lt;第一个值类型, 第二个值类型&gt; pr</code></strong></p><ul><li>第一个值类型：要储存的第一个值的数据类型</li><li>第二个值类型：要储存的第二个值的数据类型</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p1;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">long</span> <span class="type">long</span>&gt; p2;</span><br><span class="line">pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt; p3;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>老式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>列表构造 C++11</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = &#123;<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><p>直接取值</p><ul><li>取第一个值：<code>.first</code></li><li>取第二个值：<code>.second</code></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = &#123;<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="type">int</span> awa = pr.first;</span><br><span class="line"><span class="type">char</span> bwb = pr.second;</span><br></pre></td></tr></table></figure><p>结构化绑定 C++17</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = &#123;<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> &amp;[awa, bwb] = pr;</span><br></pre></td></tr></table></figure><h4 id="判同"><a href="#判同" class="headerlink" title="判同"></a>判同</h4><p>直接用 <code>==</code> 运算符</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p1 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p2 = &#123;<span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (p1 == p2) &#123; ... &#125; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="2-9-2-适用场景"><a href="#2-9-2-适用场景" class="headerlink" title="2.9.2 适用场景"></a>2.9.2 适用场景</h3><p>所有需要二元组的场景均可使用，效率和自己定义结构体差不多。</p><h3 id="2-9-3-注意事项"><a href="#2-9-3-注意事项" class="headerlink" title="2.9.3 注意事项"></a>2.9.3 注意事项</h3><p>无</p><h1 id="3-迭代器简介"><a href="#3-迭代器简介" class="headerlink" title="3 迭代器简介"></a>3 迭代器简介</h1><h2 id="3-1-迭代器是什么？"><a href="#3-1-迭代器是什么？" class="headerlink" title="3.1 迭代器是什么？"></a>3.1 迭代器是什么？</h2><p>不搞抽象，直接举例。</p><p>对于一个 vector，我们可以用下标遍历：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>我们同时也可以用迭代器来遍历：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li><code>a.begin()</code> 是一个迭代器，指向的是第一个元素</li><li><code>a.end()</code> 是一个迭代器，指向的是最后一个元素<strong>再后面一位</strong></li><li>上述迭代器具有自增运算符，自增则迭代器向下一个元素移动</li><li>迭代器与指针相似，如果对它使用解引用运算符，即 <code>*it</code>，就能取到对应值了</li></ul><h2 id="3-2-为何需要迭代器？"><a href="#3-2-为何需要迭代器？" class="headerlink" title="3.2 为何需要迭代器？"></a>3.2 为何需要迭代器？</h2><p>很多数据结构并不是线性的（例如红黑树），对于非线性数据结构，下标是无意义的。无法使用下标来遍历整个数据结构。</p><p>迭代器的作用就是定义某个数据结构的遍历方式，通过迭代器的增减，代表遍历到的位置，通过迭代器便能成功遍历非线性结构了。</p><p>例如，set 的实现是红黑树，我们是没法用下标来访问元素的。但是通过迭代器，我们就能遍历 set 中的元素了：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="3-3-迭代器用法"><a href="#3-3-迭代器用法" class="headerlink" title="3.3 迭代器用法"></a>3.3 迭代器用法</h2><p>对于 vector 容器，它的迭代器功能比较完整，以它举例：</p><ul><li><code>.begin()</code>：头迭代器</li><li><code>.end()</code>：尾迭代器</li><li><code>.rbegin()</code>：反向头迭代器</li><li><code>.rend()</code>：反向尾迭代器</li><li>迭代器 <code>+</code> 整型：将迭代器向后移动</li><li>迭代器 <code>-</code> 整型：将迭代器向前移动</li><li>迭代器 <code>++</code>：将迭代器向后移动 1 位</li><li>迭代器 <code>--</code>：将迭代器向前移动 1 位</li><li>迭代器 <code>-</code> 迭代器：两个迭代器的距离</li><li><code>prev(it)</code>：返回 it 的前一个迭代器</li><li><code>next(it)</code>：返回 it 的后一个迭代器</li></ul><p>对于其他容器，由于其结构特性，上面的功能不一定都有（例如 set 的迭代器是不能相减求距离的）</p><h2 id="3-4-常见问题"><a href="#3-4-常见问题" class="headerlink" title="3.4 常见问题"></a>3.4 常见问题</h2><p><strong><code>.end()</code> 和 <code>.rend()</code> 指向的位置是无意义的值</strong></p><p>对于一个长度为 10 的数组：<code>for (int i = 0; i &lt; 10; i++)</code>，第 10 位是不可访问的</p><p>对于一个长度为 10 的容器：<code>for (auto it = a.begin(); it != a.end(); ++it)</code>，.end 是不可访问的</p><p><strong>不同容器的迭代器功能可能不一样</strong></p><p>迭代器细化的话有正向、反向、双向，每个容器的迭代器支持的运算符也可能不同，因此不同容器的迭代器细节很有可能是不一样的。</p><p><strong>删除操作时需要警惕</strong></p><p>为什么 3 没删掉？</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span> || *it == <span class="number">3</span>)</span><br><span class="line">        a.<span class="built_in">erase</span>(it);</span><br><span class="line"><span class="comment">// a = [1, 3, 4]</span></span><br></pre></td></tr></table></figure><p>为啥 RE 了？</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">4</span>)</span><br><span class="line">        a.<span class="built_in">erase</span>(it);</span><br></pre></td></tr></table></figure><center><b>建议：如无必要，别用迭代器操作容器。（遍历与访问没关系）</b></center><h1 id="4-常用算法"><a href="#4-常用算法" class="headerlink" title="4 常用算法"></a>4 常用算法</h1><h2 id="4-1-内容总览"><a href="#4-1-内容总览" class="headerlink" title="4.1 内容总览"></a>4.1 内容总览</h2><p>打勾的是本次将会详细讲解的，其他的是算法竞赛中建议学习的，不在下表列出的在比赛中基本用不到。</p><p>（很多函数的功能很简单，自己都能快速写出来，但是使用函数可以让代码可读性变得更高，这在比赛中是至关紧要的）</p><ul><li><p>算法库 Algorithm</p><ul><li><input disabled type="checkbox"> <code>count()</code></li><li><input disabled type="checkbox"> <code>find()</code></li><li><input disabled type="checkbox"> <code>fill()</code></li><li><input checked disabled type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/algorithm/swap"><code>swap()</code></a></li><li><input checked disabled type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/algorithm/reverse"><code>reverse()</code></a></li><li><input disabled type="checkbox"> <code>shuffle()</code> C++11</li><li><input checked disabled type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/algorithm/unique"><code>unique()</code></a></li><li><input checked disabled type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/algorithm/sort"><code>sort()</code></a></li><li><input checked disabled type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/algorithm/lower_bound"><code>lower_bound()</code></a> &#x2F; <a href="https://zh.cppreference.com/w/cpp/algorithm/upper_bound"><code>upper_bound()</code></a></li><li><input checked disabled type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/algorithm/max"><code>max()</code></a> &#x2F; <a href="https://zh.cppreference.com/w/cpp/algorithm/min"><code>min()</code></a></li><li><input disabled type="checkbox"> <code>max_element()</code> &#x2F; <code>min_element()</code></li><li><input disabled type="checkbox"> <code>prev_permutation()</code> &#x2F; <code>next_permutation()</code></li></ul></li><li><p>数学函数 cmath</p><ul><li><input checked disabled type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/numeric/math/fabs"><code>abs()</code></a></li><li><input checked disabled type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/numeric/math/exp"><code>exp()</code></a></li><li><input checked disabled type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/numeric/math/log"><code>log()</code></a> &#x2F; <code>log10()</code> &#x2F; <code>log2()</code></li><li><input checked disabled type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/numeric/math/pow"><code>pow()</code></a></li><li><input checked disabled type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/numeric/math/sqrt"><code>sqrt()</code></a></li><li><input disabled type="checkbox"> <code>sin()</code> &#x2F; <code>cos()</code> &#x2F; <code>tan()</code></li><li><input disabled type="checkbox"> <code>asin()</code> &#x2F; <code>acos()</code> &#x2F; <code>atan()</code></li><li><input disabled type="checkbox"> <code>sinh()</code> &#x2F; <code>cosh()</code> &#x2F; <code>tanh()</code></li><li><input disabled type="checkbox"> <code>asinh()</code> &#x2F; <code>acosh()</code> &#x2F; <code>atanh()</code> C++11</li><li><input checked disabled type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/numeric/math/ceil"><code>ceil()</code></a> &#x2F; <a href="https://zh.cppreference.com/w/cpp/numeric/math/floor"><code>floor()</code></a></li><li><input checked disabled type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/numeric/math/round"><code>round()</code></a> C++11</li></ul></li><li><p>数值算法 numeric</p><ul><li><input disabled type="checkbox"> <code>iota()</code> C++11</li><li><input disabled type="checkbox"> <code>accumulate()</code></li><li><input checked disabled type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/numeric/gcd"><code>gcd()</code></a> C++17</li><li><input checked disabled type="checkbox"> <a href="https://zh.cppreference.com/w/cpp/numeric/lcm"><code>lcm()</code></a> C++17</li></ul></li><li><p>伪随机数生成 random</p><ul><li><input disabled type="checkbox"> <code>mt19937</code></li><li><input disabled type="checkbox"> <code>random_device()</code></li></ul></li></ul><h2 id="4-2-swap"><a href="#4-2-swap" class="headerlink" title="4.2 swap()"></a>4.2 <code>swap()</code></h2><p>交换两个变量的值</p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( T&amp; a, T&amp; b )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line"><span class="comment">// now a = 1, b = 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">swap</span>(arr[<span class="number">4</span>], arr[<span class="number">6</span>]);</span><br><span class="line"><span class="comment">// now arr = &#123;0, 1, 2, 3, 6, 5, 4, 7, 8, 9&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><p>这个 swap 参数是引用的，不需要像 C 语言一样取地址。</p><h2 id="4-3-sort"><a href="#4-3-sort" class="headerlink" title="4.3 sort()"></a>4.3 <code>sort()</code></h2><p>使用快速排序给一个可迭代对象排序</p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">( RandomIt first, RandomIt last, Compare comp )</span></span>;</span><br></pre></td></tr></table></figure><p>默认排序从小到大</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// arr = [0, 1, 1, 1, 8, 9, 9]</span></span><br></pre></td></tr></table></figure><p>如果要从大到小，则需要传比较器进去。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="comment">// arr = [9, 9, 8, 1, 1, 1, 0]</span></span><br></pre></td></tr></table></figure><p>如果需要完成特殊比较，则需要手写比较器。</p><p>比较器函数返回值是 bool 类型，传参是需要比较的两个元素。记我们定义的该比较操作为 $\star$：</p><ul><li>若 $a\star b$，则比较器函数应当返回 <code>true</code></li><li>若 $a\not\star b$，则比较器函数应当返回 <code>false</code></li></ul><p><strong>注意：</strong>如果 $a&#x3D;b$，比较器函数必须返回 <code>false</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.second != b.second)</span><br><span class="line">        <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">    <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; arr&#123;&#123;<span class="number">1</span>, <span class="number">9</span>&#125;, &#123;<span class="number">2</span>, <span class="number">9</span>&#125;, &#123;<span class="number">8</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="comment">// arr = [(0, 0), (8, 1), (2, 9), (1, 9)]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-lower-bound-upper-bound"><a href="#4-4-lower-bound-upper-bound" class="headerlink" title="4.4 lower_bound() &#x2F; upper_bound()"></a>4.4 <code>lower_bound()</code> &#x2F; <code>upper_bound()</code></h2><p>在<strong>已升序排序</strong>的元素中，应用二分查找检索指定元素，返回对应元素迭代器位置。<strong>找不到则返回尾迭代器。</strong></p><ul><li><code>lower_bound()</code>: 寻找 $\geq x$ 的第一个元素的位置</li><li><code>upper_bound()</code>: 寻找 $&gt;x$ 的第一个元素的位置</li></ul><p>怎么找 $\leq x$ &#x2F; $&lt; x$ 的第一个元素呢？</p><ul><li>$&gt;x$ 的第一个元素的前一个元素（如果有）便是 $\leq x$ 的第一个元素</li><li>$\geq x$ 的第一个元素的前一个元素（如果有）便是 $&lt;x$ 的第一个元素</li></ul><p>返回的是迭代器，如何转成下标索引呢？减去头迭代器即可。</p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">lower_bound</span><span class="params">( ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>);</span><br><span class="line"><span class="type">int</span> idx = it - arr.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// idx = 4</span></span><br></pre></td></tr></table></figure><p>我们通常写成一行：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>&#125;;</span><br><span class="line">idx = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">8</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">upper_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">upper_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">8</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h2 id="4-5-reverse"><a href="#4-5-reverse" class="headerlink" title="4.5 reverse()"></a>4.5 <code>reverse()</code></h2><p>反转一个可迭代对象的元素顺序</p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> BidirIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">( BidirIt first, BidirIt last )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</span></span><br><span class="line"><span class="built_in">reverse</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// 10, 9, 8, 7, 6, 5, 4, 3, 2, 1</span></span><br></pre></td></tr></table></figure><h2 id="4-6-max-min"><a href="#4-6-max-min" class="headerlink" title="4.6 max() &#x2F; min()"></a>4.6 <code>max()</code> &#x2F; <code>min()</code></h2><p>返回最大值 &#x2F; 最小值的<strong>数值</strong></p><p><strong>用法示例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> mx = <span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="type">int</span> mn = <span class="built_in">min</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>在 C++11 之后，可以使用列表构造语法传入一个列表，这样就能一次性给多个元素找最大值而不用套娃了：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Before C++11</span></span><br><span class="line"><span class="type">int</span> mx = <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">max</span>(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="type">int</span> mn = <span class="built_in">min</span>(<span class="built_in">min</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">min</span>(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// After C++11</span></span><br><span class="line"><span class="type">int</span> mx = <span class="built_in">max</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;); <span class="comment">// 4</span></span><br><span class="line"><span class="type">int</span> mn = <span class="built_in">min</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="4-7-unique"><a href="#4-7-unique" class="headerlink" title="4.7 unique()"></a>4.7 <code>unique()</code></h2><p>消除数组的重复<strong>相邻</strong>元素，数组长度不变，但是有效数据缩短，返回的是有效数据位置的结尾迭代器。</p><p>例如：$[1,1,4,5,1,4]\to[1,4,5,1,4,\underline?]$，下划线位置为返回的迭代器指向。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">unique</span><span class="params">( ForwardIt first, ForwardIt last )</span></span>;</span><br></pre></td></tr></table></figure><p><strong>用法示例</strong></p><p>单独使用 unique 并不能达成去重效果，因为它只消除<strong>相邻</strong>的重复元素。但是如果序列有序，那么它就能去重了。</p><p>但是它去重后，序列尾部会产生一些无效数据：$[1,1,2,4,4,4,5]\to[1,2,4,5,\underline?,?,?]$，为了删掉这些无效数据，我们需要结合 erase.</p><p>最终，给 vector 去重的写法便是：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">arr.<span class="built_in">erase</span>(<span class="built_in">unique</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>()), arr.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="4-8-数学函数"><a href="#4-8-数学函数" class="headerlink" title="4.8 数学函数"></a>4.8 数学函数</h2><p>所有函数参数均支持 <code>int</code> &#x2F; <code>long long</code> &#x2F; <code>float</code> &#x2F; <code>double</code> &#x2F; <code>long double</code></p><table><thead><tr><th>公式</th><th>示例</th></tr></thead><tbody><tr><td>$f(x)&#x3D;\lvert x\rvert$</td><td><code>abs(-1.0)</code></td></tr><tr><td>$f(x)&#x3D;e^x$</td><td><code>exp(2)</code></td></tr><tr><td>$f(x)&#x3D;\ln x$</td><td><code>log(3)</code></td></tr><tr><td>$f(x,y)&#x3D;x^y$</td><td><code>pow(2, 3)</code></td></tr><tr><td>$f(x)&#x3D;\sqrt x$</td><td><code>sqrt(2)</code></td></tr><tr><td>$f(x)&#x3D;\lceil x\rceil$</td><td><code>ceil(2.1)</code></td></tr><tr><td>$f(x)&#x3D;\lfloor x\rfloor$</td><td><code>floor(2.1)</code></td></tr><tr><td>$f(x)&#x3D;\left&lt;x\right&gt;$</td><td><code>rount(2.1)</code></td></tr></tbody></table><p><strong>注意事项</strong></p><p>由于浮点误差，有些的数学函数的行为可能与预期不符，导致 WA。如果你的操作数都是整型，那么用下面的写法会更稳妥。</p><blockquote><p>原文地址：<a href="https://codeforces.com/blog/entry/107717">https://codeforces.com/blog/entry/107717</a></p></blockquote><ul><li>$\lfloor\frac{a}{b}\rfloor$<ul><li>别用：<code>floor(1.0 * a / b)</code></li><li>要用：<code>a / b</code></li></ul></li><li>$\lceil\frac{a}{b}\rceil$<ul><li>别用：<code>ceil(1.0 * a / b)</code></li><li>要用：<code>(a + b - 1) / b</code>  （$\lceil\frac{a}{b}\rceil&#x3D;\lfloor\frac{a+b-1}{b}\rfloor$）</li></ul></li><li>$\lfloor\sqrt a\rfloor$<ul><li>别用：<code>(int) sqrt(a)</code></li><li>要用：二分查找 <a href="https://io.zouht.com/7.html">https://io.zouht.com/7.html</a></li></ul></li><li>$a^b$<ul><li>别用：<code>pow(a, b)</code></li><li>要用：快速幂 <a href="https://io.zouht.com/18.html">https://io.zouht.com/18.html</a></li></ul></li><li>$\lfloor\log_2 a\rfloor$<ul><li>别用：<code>log2(a)</code></li><li>要用：<code>__lg</code> （不规范，但是这是竞赛）&#x2F; <code>bit_width</code>（C++20 可用）</li></ul></li></ul><h2 id="4-9-gcd-lcm"><a href="#4-9-gcd-lcm" class="headerlink" title="4.9 gcd() &#x2F; lcm()"></a>4.9 <code>gcd()</code> &#x2F; <code>lcm()</code></h2><p>（C++17）返回最大公因数 &#x2F; 最小公倍数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="built_in">gcd</span>(<span class="number">8</span>, <span class="number">12</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="type">int</span> y = <span class="built_in">lcm</span>(<span class="number">8</span>, <span class="number">12</span>); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>如果不是 C++17，但是是 GNU 编译器（g++），那么可以用内置函数 <code>__gcd()</code>.</p><p>当然，<code>gcd</code> &#x2F; <code>lcm</code> 函数也挺好写，直接写也行（欧几里得算法）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / <span class="built_in">gcd</span>(a, b) * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode配置C/C++环境</title>
      <link href="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/"/>
      <url>/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="配置vscode前言"><a href="#配置vscode前言" class="headerlink" title="配置vscode前言"></a>配置vscode前言</h1><p>经过了一个学期的c语言学习，大家入门的方式通常用devc++来编写代码，因为devc简单便捷不需要配置环境，简单的下载即可使用，但页面有些老旧，界面粗糙，所以我们可以用更现代化的，功能强大的vscode。</p><p>学计算机我们应该有足够的好奇心和折腾欲，配置环境，搭建工具的工程中可以学到很多有用的东西，这是了解计算机的过程，也是进入代码世界的必经之路。 </p><p>而且现在的计算机行业非常的卷，其中一个重要的原因就是，这个行业专业壁垒较低，各行各业的人都可以转码。比如学习硬件的专业壁垒就比较高，学习起来需要买各种硬件设备，比赛的时候更是可以用充分的资金，买最好的设备来进行比赛，有先天优势。只要有充足的耐心与想法，当今行业，只要有满腔的学习热血与一台电脑，即可学好</p><h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h1><p>首先我们在使用devc++的时候，运行代码的时候都需要编译，编译之后才可以运行代码，同时源代码的目录会多出来.exe文件。具象化出来就是一下这个图</p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/b358b6596cbd3ad4981218ed519da78e2910ef.png" alt=" "></p><p><strong>区分编辑器与编译器</strong></p><p>可能你会好奇为什么下载vscode之后还需要配置环境，因为vscode只是一个编辑器，真正将代码编译成可执行代码的是编译器</p><p><strong>编辑器</strong>就是处理文本（源码）的程序，写代码写的就是文本，编辑器可能提供智能提示、代码高亮等辅助功能，但不负责源码到二进制文件的操作；</p><p><strong>编译器</strong>就是负责将源码文本翻译成计算机能够理解和执行的二进制文件的程序；</p><p>所以我们就需要将编辑器vscode与编译器gcc套件配合起来，才能实现快捷操作，这就是我们所说的搭建环境，也是那个段子的由来，<strong>同样的代码为什么我的电脑没问题你的跑不了（doge）</strong></p><h1 id="2-下载安装"><a href="#2-下载安装" class="headerlink" title="2.下载安装"></a>2.下载安装</h1><p>下载vscode与gcc</p><p>vscode官网：**<a href="https://code.visualstudio.com/">Visual Studio Code - Code Editing. Redefined</a>**</p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/b7ae9f29344c553807e661a3347cb09d196950.png" alt="img"></p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/868248580ac08ef145f138264a8978b5a95004.png" alt=" "></p><p>编译工具我们选用gcc（全称GNU Compiler Collection 意思是GNU编译器套件），不过不是原版的gcc，而是它在Windows下的特制版<strong>MinGW</strong>(全称Minimalist GNU on Windows）。它实际上是将GCC 移植到了 Windows 平台下，并且包含了 Win32API ，因此可以将源代码编译为可在 Windows 中运行的可执行程序。而且还可以使用一些 Windows 不具备的，Linux平台下的开发工具。MinGW又分为MinGW-w64 与 MinGW ，区别在于 MinGW 只能编译生成32位可执行程序，而 <strong>MinGW-w64</strong> 则可以编译生成 64位 或 32位 可执行程序。MinGW 现已被 MinGW-w64 所取代，且 MinGW 也已停止了更新。</p><p>因此，我们最终下载安装的是<strong>MinGW-w64</strong></p><p>下载地址：<a href="https://sourceforge.net/projects/mingw-w64/files/">MinGW-w64 - for 32 and 64 bit Windows - Browse Files at SourceForge.net</a></p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/4795c5995b5e7305ee7155c22d0b23d46b3203.png" alt=" ">下载解压到合适的文件夹后（推荐C:\Program Files)注意<strong>安装路径不要有中文</strong></p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/e32e474849e3c4ae2e35336a7c19a3cc284dc7.png" alt=" "></p><p>打开mingw64文件夹后，其中有bin文件夹，里面有gcc.exe和gdb.exe(调试工具，用来debug)，还有一些头文件的文件比如stdio.h的位置是C:\Program Files\mingw64\x86_64-w64-mingw32\include。</p><p>此时进入bin文件夹中并在文件夹中 按着shift+鼠标右键，打开powershell，</p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/12345.png" alt=" "></p><p>输入<strong>gcc –version</strong>  注意空格 按下回车</p><p>会出来gcc的版本号。</p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/2131231.png" alt=" "></p><p>但是当我们在别的文件夹中打开powershell输入gcc –version ，会发现无法找到gcc，接下来就要到了配置环境的步骤了，配置环境就可以任意文件下使用gcc，而不只需要在bin文件夹下使用。为了让程序能访问到这些编译程序，需要把它们所在的<strong>目录</strong>（我这里是C:\Program File\mingw64\bin，点击地址栏进行复制）<strong>添加到环境变量Path中</strong>。</p><p>用windows的搜索功能（快捷键是<code>Windows徽标键+S</code>）搜索<code>环境变量</code>，<img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/c631093565f97606a62616752e434ab1fa535e.png" alt=" "></p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/f4a81903565a06032d140781d56b8367463ec1.png" alt=" "></p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/b52ac5f57866769d8fd3404df49cfe413f0def.png" alt=" "></p><p>接下来win+r （Windows徽标键+S）搜索cmd，</p><p>出现黑框之<img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/36d222f97abde7ad9791416f47b5d8fdff70e2.png" alt=" ">后输入gcc –version(中间有空格)，按回车</p><p>说明gcc安装成功。</p><p>现在重启一下电脑。</p><p>好了，我们的电脑里已经有了这两个东西了，他们是从不同的地方下载的，安装的位置也不同，目前两者之间还没有任何联系，接下来，我们应该去搭建起他们之间的桥梁了，不过别着急，咱们先来了解一下文件结构。</p><h1 id="3-文件结构"><a href="#3-文件结构" class="headerlink" title="3.文件结构"></a>3.文件结构</h1><p>文件结构就是你组织文件夹、文件，决定他们怎样嵌套、怎样从属的方法。</p><p>这一步是区分搭建的是语言学习环境还是实际项目开发环境的关键。</p><p>这两者有什么区别呢？想想你写hello world时是怎样写的，你写了一个单文件，只有一个.c文件，然后你按下绿色三角进行编译运行生成.exe可执行文件，语言学习环境大都是这样的<strong>单文件编译运行调试</strong>，或者是涉及到<strong>简单的几个头文件和源文件的组合</strong>这样的多文件结构。而<strong>实际项目开发</strong>呢，实际中的一个小项目的目录结构可能长这样：</p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/b51cf77939b7e4a5687934536de563844257f6.png" alt=" "></p><p>我们的语言学习环境不是这样的，我们用不到lib、build、makefile等文件夹&#x2F;文件，我们的目录结构应当方便我们新建一个单文件，然后编译调试，这些文件还应当在一起以方便查看和管理</p><p>在任意位置（你自己好找的位置）创建Codefiled文件夹，之后代码都可以在这个文件下进行编写，（件夹的名字你也可以改成别的，注意路径中不要出现中文和空格，因为gcc调试器不支持中文路径）。</p><p>在Codefiled文件夹下，创建CODE_C文件夹，c语言代码可以在这里编写，同样的也可以创建CODE_CPP(c++代码）CODE+_PY（python代码）。</p><p>之后在CODE_C在创建两个文件夹C_Single（单文件工作代码） 和 C_Multiple（多文件工作代码） ，这两个就是我们的工作区文件夹了。<img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/9815da361e47567e4c9748417dbd2a028debac.png" alt=" "></p><p>之后我们在学习的过程中，会写很多的代码，将代码全堆叠在一起显然不太好看，可以将代码分类，比如章节分</p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/38a4785874f1d00024f059278e5df2e1be2fe3.png" alt=" "></p><p>或者按类型分：</p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/72f62c564466e8bf065690e881c06fe155e6e7.png" alt=" "></p><p>文件夹名字最好是简单好记的，方便日后查找，具体怎么分可以看你的学习情况。还有一个问题，源码编译后会生成exe可执行文件，它们放在哪里？和源文件放在一起的话，当文件夹下文件多起来时会非常杂乱，因此我们选择把exe文件统一放在bin文件夹下，这个bin文件夹不应当直接放在工作区文件夹下，这样会造成不同的源码分类文件夹下的文件都不能重名，于是我们在<strong>每一个分类文件夹下</strong>都建一个bin文件夹，最终效果如下：</p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/421d461222e66d4809a692cae0a2ca2c60a2fa.png" alt=" "></p><p><strong>.vscode文件等下说明</strong></p><p>C_Mutile类似但有所不同，由于一组程序由多个文件构成，我们把这C_Single中的单个源文件替换成文件夹就好，每个文件夹里面就是一组源文件，并且exe文件也放在其中，不需要单独的bin目录。</p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/e5fc3d5886ab22903f39549fdb819c4847dbda.png" alt=" "></p><p>至此，你有了一个合适的文件结构，我们可以开始进行 vscode 的配置了。</p><h1 id="4-vscode配置文件"><a href="#4-vscode配置文件" class="headerlink" title="4.vscode配置文件"></a><strong>4.vscode配置文件</strong></h1><p>这一步开始前，我们再来了解几个概念。</p><p><strong>命令行</strong>：命令行 或 命令行界面，是一种基于文本的用来查看、处理、和操作计算机上的文件和程序的工具。</p><p><strong>终端&#x2F;控制台</strong>：普通用户可以简单的把终端和控制台理解为：可以输入命令行并显示程序运行过程中的信息以及程序运行结果的窗口。 不必要严格区分这两者的差别。</p><p><strong>shell</strong>：终端自身并不执行用户输入的命令，它只是负责把输入的内容传送到主机系统，并把主机系统返回的结果呈现给用户。负责解释执行用户输入的命令并返回结果的，正是Shell，它是沟通用户和系统内核的中间桥梁。</p><p>现在思考一个问题，我们搭的这套环境中编辑器选的是vscode，但理论上任何能处理文本的编辑器都能用来写代码，比如Windows自带的记事本，你可以在桌面新建一个txt文件，命名为hello，然后用记事本写个helloworld程序进去，再把这个文件后缀改成.c，这就是一个源代码文件了，我们该如何对它进行编译运行呢？答案是通过<strong>命令行</strong>，我们已经安装了编译器套装并把它添加进了环境变量，现在可以使用gcc命令了：搜索打开cmd命令提示符，默认进入的是用户目录，输入cd desktop 进入桌面目录，像这样：</p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/23bbab9418a747a4ad4922b0fee1b7e61e6ee2.png" alt=" "></p><p>然后输入编译命令 <code>gcc -o hello hello.c</code>（注意空格），按下回车，你会发现桌面多了hello.exe文件，这说明我们成功编译生成了可执行文件，然后再在命令行中输入<code>hello.exe</code>运行程序 。</p><p>这样每次都用命令行太麻烦了，我们希望用更快捷的方式执行这一过程，但记事本不是专门给你写代码的，它不能提供这样的配置，但是vscode就不一样了，专门写代码的编辑器当然有专门的方式让你快捷地编译运行。这是通过.vscode文件夹下的json配置文件实现的，这些json文件怎么写是由vscode开发团队规定的（感兴趣可以去看官方的文档），其中一个是tasks.json，task是任务的意思，我们的编译和运行就是我们想要vscode执行的任务，为此我们要在tasks.json里写两个task：<code>Build</code>和<code>Run</code>(这里为什么不是<code>Compile</code>呢？是因为从源码到可执行的过程中不仅是<strong>编译(Compile)</strong>,还有预编译、链接等过程，用 <strong>构建(Build)</strong> 来表述更合适)。除了编译和运行，我们还需要进行**调试(Debug)**，这个就不是通过task来实现的了，而是通过<code>launch.json</code>文件来实现。</p><p>现在，打开vscode，发现全是英文，我们先装个汉化插件：</p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/489948c963afc23efc6219380020183d078082.png" alt=" "></p><p>然后搜索C&#x2F;C++安装这个插件，这是对语言的支持插件</p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/46f6d15021e84f5520f0425d79563be454135e.png" alt=" "></p><p>重启vscode，打开C_Single文件夹：</p><p>注意要 文件-&gt;打开文件夹 这样打开，vscode中打开的<strong>根目录</strong>是C_Single</p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/b3a85f4320fd73548101862a217eedfb617107.png" alt=" "><strong>然后新建.vscode文件夹(注意前面有个.),然后在里面新建<code>tasks.json</code>和<code>launch.json</code></strong></p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/a80814917f59d040fd4625f3322889e6f9f512.png" alt=" "></p><p>打开的根目录是C_Single</p><p>下面是这两个文件的具体内容，带有详细注释，你要大致看一遍，看不太懂没关系。复制粘贴到你的文件里，<strong>注意里面有一些路径之类的东西需要你进行修改，还有一点是这里的配置和上一步中提到的工作区下的文件结构是严格一致的，必须那样组织文件。</strong></p><p>将一下代码对应复制粘贴，注意上一段的提醒</p><p>tasks.json</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;//这个大括号里是‘构建（build）’任务</span><br><span class="line">            &quot;label&quot;: &quot;build&quot;, //任务名称，可以更改，不过不建议改</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;, //任务类型，process是vsc把预定义变量和转义解析后直接全部传给command；shell相当于先打开shell再输入命令，所以args还会经过shell再解析一遍</span><br><span class="line">            &quot;command&quot;: &quot;gcc&quot;, //编译命令，这里是gcc，编译c++的话换成g++</span><br><span class="line">            &quot;args&quot;: [    //方括号里是传给gcc命令的一系列参数，用于实现一些功能</span><br><span class="line">                &quot;$&#123;file&#125;&quot;, //指定要编译的是当前文件</span><br><span class="line">                &quot;-o&quot;, //指定输出文件的路径和名称</span><br><span class="line">                &quot;$&#123;fileDirname&#125;\\bin\\$&#123;fileBasenameNoExtension&#125;.exe&quot;, //承接上一步的-o，让可执行文件输出到源码文件所在的文件夹下的bin文件夹内，并且让它的名字和源码文件相同</span><br><span class="line">                &quot;-g&quot;, //生成和调试有关的信息</span><br><span class="line">                &quot;-Wall&quot;, // 开启额外警告</span><br><span class="line">                &quot;-static-libgcc&quot;,  // 静态链接libgcc</span><br><span class="line">                &quot;-fexec-charset=GBK&quot;, // 生成的程序使用GBK编码，不加这一条会导致Win下输出中文乱码</span><br><span class="line">                &quot;-std=c11&quot;, // 语言标准，可根据自己的需要进行修改，写c++要换成c++的语言标准，比如c++11</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &#123;  //group表示‘组’，我们可以有很多的task，然后把他们放在一个‘组’里</span><br><span class="line">                &quot;kind&quot;: &quot;build&quot;,//表示这一组任务类型是构建</span><br><span class="line">                &quot;isDefault&quot;: true//表示这个任务是当前这组任务中的默认任务</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;presentation&quot;: &#123; //执行这个任务时的一些其他设定</span><br><span class="line">                &quot;echo&quot;: true,//表示在执行任务时在终端要有输出</span><br><span class="line">                &quot;reveal&quot;: &quot;always&quot;, //执行任务时是否跳转到终端面板，可以为always，silent，never</span><br><span class="line">                &quot;focus&quot;: false, //设为true后可以使执行task时焦点聚集在终端，但对编译来说，设为true没有意义，因为运行的时候才涉及到输入</span><br><span class="line">                &quot;panel&quot;: &quot;new&quot; //每次执行这个task时都新建一个终端面板，也可以设置为shared，共用一个面板，不过那样会出现‘任务将被终端重用’的提示，比较烦人</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;problemMatcher&quot;: &quot;$gcc&quot; //捕捉编译时编译器在终端里显示的报错信息，将其显示在vscode的‘问题’面板里</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;//这个大括号里是‘运行(run)’任务，一些设置与上面的构建任务性质相同</span><br><span class="line">            &quot;label&quot;: &quot;run&quot;, </span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;, </span><br><span class="line">            &quot;dependsOn&quot;: &quot;build&quot;, //任务依赖，因为要运行必须先构建，所以执行这个任务前必须先执行build任务，</span><br><span class="line">            &quot;command&quot;: &quot;$&#123;fileDirname&#125;\\bin\\$&#123;fileBasenameNoExtension&#125;.exe&quot;, //执行exe文件，只需要指定这个exe文件在哪里就好</span><br><span class="line">            &quot;group&quot;: &#123;</span><br><span class="line">                &quot;kind&quot;: &quot;test&quot;, //这一组是‘测试’组，将run任务放在test组里方便我们用快捷键执行</span><br><span class="line">                &quot;isDefault&quot;: true</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;presentation&quot;: &#123;</span><br><span class="line">                &quot;echo&quot;: true,</span><br><span class="line">                &quot;reveal&quot;: &quot;always&quot;,</span><br><span class="line">                &quot;focus&quot;: true, //这个就设置为true了，运行任务后将焦点聚集到终端，方便进行输入</span><br><span class="line">                &quot;panel&quot;: &quot;new&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>launch.json</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,  </span><br><span class="line">    &quot;configurations&quot;: [  </span><br><span class="line">        &#123;//这个大括号里是我们的‘调试(Debug)’配置  </span><br><span class="line">            &quot;name&quot;: &quot;Debug&quot;, // 配置名称  </span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;, // 配置类型，cppdbg对应cpptools提供的调试功能；可以认为此处只能是cppdbg</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;, // 请求配置类型，可以为launch（启动）或attach（附加）</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\bin\\$&#123;fileBasenameNoExtension&#125;.exe&quot;, // 将要进行调试的程序的路径</span><br><span class="line">            &quot;args&quot;: [], // 程序调试时传递给程序的命令行参数，这里设为空即可</span><br><span class="line">            &quot;stopAtEntry&quot;: false, // 设为true时程序将暂停在程序入口处，相当于在main上打断点</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;, // 调试程序时的工作目录，此处为源码文件所在目录</span><br><span class="line">            &quot;environment&quot;: [], // 环境变量，这里设为空即可</span><br><span class="line">            &quot;externalConsole&quot;: false, // 为true时使用单独的cmd窗口，跳出小黑框；设为false则是用vscode的内置终端，建议用内置终端</span><br><span class="line">            &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;, // 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡，新手调试用不到</span><br><span class="line">            &quot;MIMode&quot;: &quot;gdb&quot;, // 指定连接的调试器，gdb是minGW中的调试程序</span><br><span class="line">            &quot;miDebuggerPath&quot;: &quot;C:\\Program Files\\mingw64\\bin\\gdb.exe&quot;, // 指定调试器所在路径，如果你的minGW装在别的地方，则要改成你自己的路径，注意间隔是\\</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;build&quot; // 调试开始前执行的任务，我们在调试前要编译构建。与tasks.json的label相对应，名字要一样</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里已经差不多完成了</p><p>写一个简单的hello合成来运行一下有没有问题</p><p>首先在C_Single下新建一个exercise文件夹，来组织源码文件，在exercise下新建<code>hello.c</code>文件，然后在exercise下建一个bin文件夹（注意从属关系，不要建错了，在vscode中想在某个目录下新建文件&#x2F;文件夹要<strong>先点击一下该目录，再点击新建按钮</strong>），hello.c中输入如下代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char name[10];</span><br><span class="line">    printf(&quot;Input your name: &quot;);</span><br><span class="line">    scanf(&quot;%s&quot;,name);</span><br><span class="line">    printf(&quot;Hello,%s,this is your vscode!\n&quot;,name);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写好后<code>ctrl+s</code>保存，进行如下操作：</p><ul><li>仅编译（构建），用快捷键<code>ctrl+shift+B</code>,你会发现终端面板打开了，显示如下：</li></ul><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/c80465a3931065533116374a352bf6cfe061ae.png" alt=" "></p><p>没有报错，bin文件夹下多了hello.exe，编译成功！</p><ul><li>编译（构建）+运行，测试任务默认没有快捷键，我们自己绑定一个：点击左下角小齿轮-&gt;键盘快捷方式-&gt;搜索<code>任务</code>-&gt;找到<code>运行测试任务</code>,点击左侧加号添加键绑定，这里我们设为<code>F4</code>，</li></ul><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/14c5fc418a9a2b852ff6517e432534b5fff470.png" alt=" "></p><p>然后回到我们的hello程序页面，按下F4,显示如下：</p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/010df39819d421f59c5574a67b47f3dc5eb78b.png" alt=" "></p><p>输入你的名字，按下回车，运行成功！</p><ul><li>接下来是调试（vscode的调试功能非常直观易用，你会爱上它的），在第一个printf处打上断点（点击行号前面的小红点，或者用快捷键F9)，然后打开左侧的运行面板，点击绿色小三角开始调试（或者直接用调试快捷键F5）</li></ul><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/299940866de9c0bb3d5867466dd313c22b0580.png" alt=" "></p><p>然后会出现调试工具栏，各按钮功能如图：</p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/28104a144779f8947c263926d89cd690999b47.png" alt=" "></p><p>左侧可以查看、监控变量</p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/333dd7f871ded2bffda884e8ff83e39b70669a.png" alt=" "></p><p>我们使用单步调试按钮，快捷键F11,单步向下执行程序，黄色箭头所指示行是现在未执行、下一步将要执行的语句，当执行到输入语句时，黄色箭头会消失，这时你在终端面板内进行输入，然后按回车，黄色箭头重新出现，可以继续向下执行。</p><p>调试成功！</p><p>今后就可以新建源文件写程序，<code>F4</code>一键编译运行，<code>F5</code>一键开始调试</p><h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><ul><li><strong>中文乱码</strong></li></ul><p>乱码问题是由于文件编码格式引起的，vscode默认的编码格式是UTF-8，而Windows的终端的默认编码是GBK，这就造成了中文会显示成乱码，解决办法是生成程序时指定用GBK，我们的task里已经指定了，所以理论上你不应该出现这个问题</p><ul><li><strong>找不到头文件</strong></li></ul><p>正确添加了环境变量的话，不应该出现这个问题</p><ul><li><strong>“终端将被任务重用，按任意键关闭终端”</strong></li></ul><p>按照我们在task中的设置，每次执行一个task就会打开一个新的终端面板，你可以在下拉列表查看自己打开的面板：</p><p><img src="/2024/02/07/VScode%E9%85%8D%E7%BD%AEC-C++%E7%8E%AF%E5%A2%83/93c076b558723a79135386b041a1bd2d0ce0b6.png" alt=" "></p><p>如果你把task的”panle”属性改成了”shared”,所有的任务都用的这一个终端，vscode会提醒你“终端将被任务重用”，这句话并不是报错，只是提醒，你无视它就好，而且在设置里还可以关闭这句提醒。</p><blockquote><p>关于code runner<br>你可能在很多其他人的教程里见过它，这是一个第三方的插件，用它也可以实现编译运行，原理也是代替你手动输入命令行，也需要一定的配置。不过我觉得按照我的方法已经能很简单便捷地实现编译运行调试了，没必要再用这个插件。</p></blockquote><h1 id="简单的多文件程序"><a href="#简单的多文件程序" class="headerlink" title="简单的多文件程序"></a>简单的多文件程序</h1><p>我们已经搞定了C_Single，多文件的C_Multiple的设置也类似，只需要改一下那两个配置文件涉及到路径的部分，文件如下，你可以对比一下：</p><p><strong>多文件tasks.json</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;build&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;gcc&quot;, //写c++换成g++</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;$&#123;fileDirname&#125;\\*.c&quot;, //写c++把 *.c 换成 *.cpp</span><br><span class="line">                &quot;-o&quot;,</span><br><span class="line">                &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,</span><br><span class="line">                &quot;-g&quot;,</span><br><span class="line">                &quot;-Wall&quot;, </span><br><span class="line">                &quot;-static-libgcc&quot;,   </span><br><span class="line">                &quot;-fexec-charset=GBK&quot;,</span><br><span class="line">                &quot;-std=c11&quot;,  //写c++换成c++标准</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &#123;</span><br><span class="line">                &quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">                &quot;isDefault&quot;: true</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;presentation&quot;: &#123;</span><br><span class="line">                &quot;echo&quot;: true,</span><br><span class="line">                &quot;reveal&quot;: &quot;always&quot;,</span><br><span class="line">                &quot;focus&quot;: false,</span><br><span class="line">                &quot;panel&quot;: &quot;new&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;problemMatcher&quot;: &quot;$gcc&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;run&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;dependsOn&quot;: &quot;build&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,</span><br><span class="line">            &quot;group&quot;: &#123;</span><br><span class="line">                &quot;kind&quot;: &quot;test&quot;,</span><br><span class="line">                &quot;isDefault&quot;: true</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;presentation&quot;: &#123;</span><br><span class="line">                &quot;echo&quot;: true,</span><br><span class="line">                &quot;reveal&quot;: &quot;always&quot;,</span><br><span class="line">                &quot;focus&quot;: true,</span><br><span class="line">                &quot;panel&quot;: &quot;new&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多文件launch.json</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [&#123;</span><br><span class="line">        &quot;name&quot;: &quot;Debug&quot;, </span><br><span class="line">        &quot;type&quot;: &quot;cppdbg&quot;, </span><br><span class="line">        &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">        &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,</span><br><span class="line">        &quot;args&quot;: [],</span><br><span class="line">        &quot;stopAtEntry&quot;: false, </span><br><span class="line">        &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;, </span><br><span class="line">        &quot;environment&quot;: [], </span><br><span class="line">        &quot;externalConsole&quot;: false,</span><br><span class="line">        &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;,</span><br><span class="line">        &quot;MIMode&quot;: &quot;gdb&quot;, </span><br><span class="line">        &quot;miDebuggerPath&quot;: &quot;C:\\Program Files\\mingw64\\bin\\gdb.exe&quot;, </span><br><span class="line">        &quot;preLaunchTask&quot;: &quot;build&quot; </span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个文件夹有不同的配置，写单文件时就打开C_Single，写多文件时就打开C_Multiple，注意对应的文件结构。</p><p>有一点要注意，在写多文件时，包含自己写的头文件要用双引号，而不是尖括号，例如<code>#include &quot;myHeader.h&quot;</code>,双引号表示先在当前目录下寻找头文件。</p><p>你可以自己写个简单的多文件程序测试一下有没有问题。</p><h1 id="5-vscode丰富的插件"><a href="#5-vscode丰富的插件" class="headerlink" title="5.vscode丰富的插件"></a>5.vscode丰富的插件</h1><p>vscode的一大优点就在于插件生态丰富，通过插件可以扩展很多功能。这里推荐几个：</p><ul><li>one dark pro</li></ul><p>主题插件，好像是下载量最多的主题插件，整体配色比较和谐。（vscode在颜值方面真的很能打）</p><ul><li>Material Icon Theme</li></ul><p>一套精心设计的图标，可以让你的文件&#x2F;文件夹更有辨识度</p><ul><li>Code Time</li></ul><p>可以多维度的记录你在vscode上花的时间，可以用这个插件记录你码代码的时间，比如你可以定个类似每天编程2小时之类的目标，督促激励自己学习编程。</p><ul><li>Power Mode</li></ul><p>这是一个炫酷的插件，可以给你敲代码的过程添加特效，效果炸裂，具体操作可以看插件详情页。</p><p>还有其他很多有用有趣的插件，你可以看看别人的推荐帖。</p><p>另外vscode还有其他很多功能，比如快捷键、小地图、搜索查找替换、代码片段、集成git等等，你可以慢慢探索。</p><p>此外vscode也可以配置python环境，来使用python</p>]]></content>
      
      
      
        <tags>
            
            <tag> 配置VScode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2024/02/06/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/02/06/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么搭建博客网站"><a href="#为什么搭建博客网站" class="headerlink" title="为什么搭建博客网站"></a>为什么搭建博客网站</h1><h2 id="1-个人记录笔记"><a href="#1-个人记录笔记" class="headerlink" title="1.个人记录笔记"></a>1.个人记录笔记</h2><p><img src="https://pic2.zhimg.com/80/v2-507ee9d01487b82476412951fe385afb_720w.webp" alt="img"></p><p>因为在学习计算机的途中，会学习许多内容，学习之后如果用的不够多，会逐渐的忘去，所以是为了以后找资料的时候更方便。而且学习的时候需要有输出，写博客就是一个很好的输出手段，可以更好的将自己所学的知识汇总。</p><p>总以为学会了，写文章的时候才发现很多地方都不是特别明白。为了写好文章，对得起读者，肯定得搞清楚了才敢写完发出去。</p><p>即使写了文章，过一段时间，有些技术细节慢慢也会忘。但是忘了的时候，还会有个大概印象，找到文章一看，因为是自己写的嘛，很快就能想起来了。</p><p>写文章可以倒逼自己学习。如果你想持续输出文章，就得不断的进货——学技术，或者是学新技术，或者是把老技术往深里学。以前我就比较爱看书，自从开始写[博客]了，我看的书更多、更认真了。</p><p>让自己养成了思考和总结的习惯。比如曾经有过一篇文章《精通那么多技术为何还是做不好一个项目？》，就是多年工作的一个总结思考。</p><h2 id="2-个人兴趣"><a href="#2-个人兴趣" class="headerlink" title="2.个人兴趣"></a>2.个人兴趣</h2><p>在网上查找资料的时候，看到很多人都把文章放到自己的博客网站中，网站做的也十分美观，好玩，所以就想趁寒假时间多，搭建一个博客网站，并一点点的美化，输出内容。</p><p>而且最好的学习就是去玩着学习，兴趣是最好的老师，你想想当游戏卡关时，boss打不过去时，就会去网上搜索攻略，或者自己潜心研究，最后游戏通关时的成就感是无与伦比的。学习也应该是这种状态。</p><p>搭建博客也是一个非常有意思且不难的技术，俗话说前人搭树后人乘凉，现在有很多做好的博客模板来使用，相当于别人已经把舞台零件给准备好了，而你所做的只需要将这些零件给一点点搭建起来，当舞台搭建好之后，就需要开始美化了，美化过程也挺有趣，像一点点装修自己的小房子一样。</p><p>之后有想法自己搭建服务器来开发博客网站</p><p>搭建博客只需要有充足的耐心与细心即可搭建完成。<a href="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客（超详细） - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 为什么搭建博客网站 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
